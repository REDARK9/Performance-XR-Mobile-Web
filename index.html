<html><head><style>body {
   color: black;
}
</style></head><body><p>⟶ E-BOOK</p>
<p><img src="_page_0_Picture_1.jpeg" alt=""></p>
<h1 id="-optimize-your-game-performance-for-mobile-xr-and-the-web-in-unity-"><strong>Optimize your game performance for mobile, XR, and the web in Unity</strong></h1>
<p><img src="_page_0_Picture_3.jpeg" alt=""></p>
<p><img src="_page_0_Picture_4.jpeg" alt=""></p>
<h2 id="-contents-"><strong>Contents</strong></h2>
<table>
<thead>
<tr>
<th>Introduction 8</th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td>Choose URP for performance and visual quality 9</td>
<td></td>
</tr>
<tr>
<td></td>
<td>Rendering optimization 10</td>
<td></td>
</tr>
<tr>
<td></td>
<td>Profiling tips 11</td>
<td></td>
</tr>
<tr>
<td></td>
<td>Profile early, often, and on the target device 11</td>
<td></td>
</tr>
<tr>
<td></td>
<td>Focus on optimizing the right areas 12</td>
<td></td>
</tr>
<tr>
<td></td>
<td>Understand how the Unity Profiler works 14</td>
<td></td>
</tr>
<tr>
<td></td>
<td>Use the Profile Analyzer 18</td>
<td></td>
</tr>
<tr>
<td></td>
<td>Work on a specific time budget per frame 18</td>
<td></td>
</tr>
<tr>
<td></td>
<td>Account for device temperature 19</td>
<td></td>
</tr>
<tr>
<td></td>
<td>Determine if you are GPU-bound or CPU-bound 19</td>
<td></td>
</tr>
<tr>
<td></td>
<td>Test on both min-spec and max-spec devices 20</td>
<td></td>
</tr>
<tr>
<td></td>
<td>Memory management for XR, web, and mobile games 21</td>
<td></td>
</tr>
<tr>
<td></td>
<td>Efficient memory management 21</td>
<td></td>
</tr>
<tr>
<td></td>
<td>Use the Memory Profiler 23</td>
<td></td>
</tr>
<tr>
<td></td>
<td>Reduce the impact of garbage collection (GC) 23</td>
<td></td>
</tr>
<tr>
<td></td>
<td>Time garbage collection whenever possible 24</td>
<td></td>
</tr>
<tr>
<td></td>
<td>Use the Incremental Garbage Collector<br>to split the GC workload 24</td>
<td></td>
</tr>
<tr>
<td></td>
<td>Adaptive Performance 25</td>
<td></td>
</tr>
<tr>
<td></td>
<td>Assets 27</td>
<td></td>
</tr>
<tr>
<td></td>
<td>Import textures correctly 28</td>
<td></td>
</tr>
<tr>
<td></td>
<td>Compress textures 29</td>
<td></td>
</tr>
<tr>
<td></td>
<td>Adjust mesh import settings 30</td>
<td></td>
</tr>
<tr>
<td></td>
<td>Check your polygon counts 31</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>Automate your import settings<br>using the AssetPostprocessor 31</th>
</tr>
</thead>
<tbody>
<tr>
<td>Unity DataTools 31</td>
</tr>
<tr>
<td>Use the Addressable Asset System 32</td>
</tr>
<tr>
<td>Programming and code architecture 33</td>
</tr>
<tr>
<td>Understand the Unity PlayerLoop 34</td>
</tr>
<tr>
<td>Minimize code that runs every frame 35</td>
</tr>
<tr>
<td>Avoid heavy logic in Start/Awake 35</td>
</tr>
<tr>
<td>Avoid empty Unity events 36</td>
</tr>
<tr>
<td>Remove Debug Log statements 36</td>
</tr>
<tr>
<td>Use hash values instead of string parameters 37</td>
</tr>
<tr>
<td>Choose the right data structure 37</td>
</tr>
<tr>
<td>Avoid adding components at runtime 37</td>
</tr>
<tr>
<td>Cache GameObjects and components 37</td>
</tr>
<tr>
<td>Use object pools 38</td>
</tr>
<tr>
<td>Use ScriptableObjects 39</td>
</tr>
<tr>
<td>Project configuration 41</td>
</tr>
<tr>
<td>Reduce or disable Accelerometer Frequency 41</td>
</tr>
<tr>
<td>Disable unnecessary Player or Quality settings 42</td>
</tr>
<tr>
<td>Disable unnecessary physics 42</td>
</tr>
<tr>
<td>Choose the right frame rate 42</td>
</tr>
<tr>
<td>Avoid large hierarchies 42</td>
</tr>
<tr>
<td>Transform once, not twice 43</td>
</tr>
<tr>
<td>Vsync in XR, web, and mobile development 43</td>
</tr>
<tr>
<td>Vsync Count 44</td>
</tr>
<tr>
<td>Graphics and GPU optimization 45</td>
</tr>
<tr>
<td>GPU optimization 47</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>Benchmark the GPU 47</th>
</tr>
</thead>
<tbody>
<tr>
<td>Watch the rendering statistics 48</td>
</tr>
<tr>
<td>Reduce Draw Calls 49</td>
</tr>
<tr>
<td>Use draw call batching 49</td>
</tr>
<tr>
<td>GPU Resident Drawer 51</td>
</tr>
<tr>
<td>Use the Frame Debugger 52</td>
</tr>
<tr>
<td>Split Graphics Jobs 53</td>
</tr>
<tr>
<td>Avoid too many dynamic lights 53</td>
</tr>
<tr>
<td>Disable shadows 54</td>
</tr>
<tr>
<td>Bake your lighting into lightmaps 54</td>
</tr>
<tr>
<td>GPU light baking 55</td>
</tr>
<tr>
<td>Use Light Layers 56</td>
</tr>
<tr>
<td>Adaptive Probe Volumes 56</td>
</tr>
<tr>
<td>Use Level of Detail (LOD) 58</td>
</tr>
<tr>
<td>Use occlusion culling to remove hidden objects 59</td>
</tr>
<tr>
<td>GPU occlusion culling 59</td>
</tr>
<tr>
<td>Avoid mobile native resolution 60</td>
</tr>
<tr>
<td>Limit use of cameras 60</td>
</tr>
<tr>
<td>Spatial-Temporal Post-Processing 60</td>
</tr>
<tr>
<td>Shaders 62</td>
</tr>
<tr>
<td>Keep shaders simple and optimized 62</td>
</tr>
<tr>
<td>Minimize overdraw and alpha blending 63</td>
</tr>
<tr>
<td>Limit post-processing effects 64</td>
</tr>
<tr>
<td>Be careful with Renderer.material 64</td>
</tr>
<tr>
<td>Optimize SkinnedMeshRenderers 64</td>
</tr>
<tr>
<td>Minimize reflection probes 65</td>
</tr>
<tr>
<td>System Metrics Mali 65</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>User interface 67</th>
</tr>
</thead>
<tbody>
<tr>
<td>UGUI performance optimization tips 67</td>
</tr>
<tr>
<td>Divide your Canvases 67</td>
</tr>
<tr>
<td>Hide invisible UI elements 68</td>
</tr>
<tr>
<td>Limit GraphicRaycasters and disable Raycast Target 68</td>
</tr>
<tr>
<td>Avoid Layout Groups 69</td>
</tr>
<tr>
<td>Avoid large List and Grid views 69</td>
</tr>
<tr>
<td>Avoid numerous overlaid elements 69</td>
</tr>
<tr>
<td>Use multiple resolutions and aspect ratios  69</td>
</tr>
<tr>
<td>When using a fullscreen UI, hide everything else . 70</td>
</tr>
<tr>
<td>Assign the Camera to World Space<br>and Camera Space Canvases 70</td>
</tr>
<tr>
<td>UI Toolkit performance optimization tips 71</td>
</tr>
<tr>
<td>Use efficient layouts 71</td>
</tr>
<tr>
<td>Avoid expensive operations in Update 71</td>
</tr>
<tr>
<td>Optimize event handling 72</td>
</tr>
<tr>
<td>Optimize style sheets 72</td>
</tr>
<tr>
<td>Profile and optimize 72</td>
</tr>
<tr>
<td>Test on target platforms 72</td>
</tr>
<tr>
<td>Audio 73</td>
</tr>
<tr>
<td>Make sound clips mono when possible 74</td>
</tr>
<tr>
<td>Use original uncompressed WAV files<br>as your source assets 74</td>
</tr>
<tr>
<td>Compress the clip and reduce the compression bitrate 74</td>
</tr>
<tr>
<td>Choose the proper Load Type 75</td>
</tr>
<tr>
<td>Unload muted AudioSources from memory 75</td>
</tr>
<tr>
<td>Use the Sample Rate Setting 75</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>Animation 76</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>Use generic rather than humanoid rigs 76</td>
<td></td>
</tr>
<tr>
<td>Use alternatives for simple animation 77</td>
<td></td>
</tr>
<tr>
<td>Avoid scale curves 77</td>
<td></td>
</tr>
<tr>
<td>Update only when visible 77</td>
<td></td>
</tr>
<tr>
<td>Optimize workflow 77</td>
<td></td>
</tr>
<tr>
<td>Separate animating hierarchies 78</td>
<td></td>
</tr>
<tr>
<td>Minimize binding costs 78</td>
<td></td>
</tr>
<tr>
<td>Avoid using component-based constraints on deep<br>hierarchies 78</td>
<td></td>
</tr>
<tr>
<td>Consider performance implications<br>of animation rigging 78</td>
<td></td>
</tr>
<tr>
<td>Physics 79</td>
<td></td>
</tr>
<tr>
<td>Simplify colliders 79</td>
<td></td>
</tr>
<tr>
<td>Optimize your settings 80</td>
<td></td>
</tr>
<tr>
<td>Adjust simulation frequency 80</td>
<td></td>
</tr>
<tr>
<td>Modify CookingOptions for MeshColliders 82</td>
<td></td>
</tr>
<tr>
<td>Use Physics.BakeMesh 83</td>
<td></td>
</tr>
<tr>
<td>Use Box Pruning for large scenes 84</td>
<td></td>
</tr>
<tr>
<td>Modify solver iterations 85</td>
<td></td>
</tr>
<tr>
<td>Disable automatic transform syncing 86</td>
<td></td>
</tr>
<tr>
<td>Use Contact Arrays 87</td>
<td></td>
</tr>
<tr>
<td>Reuse Collision Callbacks 87</td>
<td></td>
</tr>
<tr>
<td>Move static colliders 88</td>
<td></td>
</tr>
<tr>
<td>Use non-allocating queries 89</td>
<td></td>
</tr>
<tr>
<td>Batch queries for ray casting 89</td>
<td></td>
</tr>
<tr>
<td>Visualize with the Physics Debugger 90</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>Workflow and collaboration 90</th>
</tr>
</thead>
<tbody>
<tr>
<td>Unity Version Control 91</td>
</tr>
<tr>
<td>Break up large scenes 92</td>
</tr>
<tr>
<td>Remove unused resources 92</td>
</tr>
<tr>
<td>Platform-specific tips for Unity Web Builds 92</td>
</tr>
<tr>
<td>Framerate 93</td>
</tr>
<tr>
<td>Publishing settings for Unity Web 93</td>
</tr>
<tr>
<td>Compression 93</td>
</tr>
<tr>
<td>Strip engine code 94</td>
</tr>
<tr>
<td>Choose &quot;None&quot; in the Enable Exceptions setting . 95</td>
</tr>
<tr>
<td>Target WebAssembly 2023 feature set 96</td>
</tr>
<tr>
<td>Code Optimization settings 96</td>
</tr>
<tr>
<td>Profiling Unity Web Builds 96</td>
</tr>
<tr>
<td>Chrome DevTools 96</td>
</tr>
<tr>
<td>XR optimization tips 97</td>
</tr>
<tr>
<td>Render Mode 97</td>
</tr>
<tr>
<td>Foveated rendering 98</td>
</tr>
<tr>
<td>Utilize the XR Interaction Toolkit 99</td>
</tr>
<tr>
<td>Performance testing for XR optimization 100</td>
</tr>
<tr>
<td>Resources for advanced developers and artists 100</td>
</tr>
</tbody>
</table>
<h2 id="-span-id-page-7-0-span-introduction"><span id="page-7-0"></span>Introduction</h2>
<p>This guide brings together all the best and latest mobile, XR, and Unity Web performance optimization tips for Unity 6. It is one of two optimization guides available, the other being <em>Optimize your game performance for consoles and PC in Unity</em>.</p>
<p>Optimizing your mobile, XR, or Unity Web application is an essential process that underpins the entire game development cycle. Hardware continues to evolve, and your game&#39;s optimization – along with its art, game design, audio, and monetization strategy – plays a key role in shaping the player experience.</p>
<p>Mobile, XR, and web games have active user bases reaching the billions. In the case of mobile, if your game is highly optimized, it has a better chance at passing certification from platformspecific stores. Aim for a performant application on the widest range of devices to maximize your opportunity for success at launch and beyond.</p>
<p>This e-book assembles knowledge and advice from Unity engineers who have partnered with developers across the industry to help them launch the best games possible.</p>
<p>Start optimizing with support from the Unity team. 1</p>
<p><sup>1</sup> Note that many of the optimizations discussed here may introduce additional complexity, which can mean extra maintenance and potential bugs. Balance performance gains against the time and labor cost when implementing these best practices.</p>
<h2 id="-span-id-page-8-0-span-choose-urp-for-performance-and-visual-quality"><span id="page-8-0"></span>Choose URP for performance and visual quality</h2>
<p>Unity recommends the <a href="https://docs.unity3d.com/6000.0/Documentation/Manual/urp/urp-introduction.html">Universal Render Pipeline</a> (URP) for developing XR (extended reality), web, and mobile games and applications. URP is designed for high performance and scalability, offering efficient rendering that can adapt to a wide range of hardware. It enables you to achieve better visual quality while maintaining smooth performance, making it ideal for platforms where resource efficiency is crucial, such as WebGL and mobile devices. Additionally, URP allows for easier customization, ensuring your applications run optimally across diverse environments.</p>
<p><img src="_page_8_Picture_2.jpeg" alt=""></p>
<p>Choose URP as your render pipeline if you are developing a Unity mobile, XR, or web game.</p>
<p><span id="page-9-0"></span><img src="_page_9_Picture_0.jpeg" alt=""></p>
<p>In addition to selecting the URP you can adjust the render pipeline asset to further customize your settings.</p>
<h2 id="rendering-optimization">Rendering optimization</h2>
<p>URP offers presets tailored for quality and performance. for tetherless VR experiences or AR apps on mobile devices. Selecting the appropriate render settings optimizes your application for mobile hardware, ensuring efficient rendering and smooth performance. The optimized settings of URP manage texture quality, shadow resolution, and lighting efficiently, providing a balance between visual fidelity and performance suitable for the constraints of mobile and tetherless XR devices.</p>
<table>
<thead>
<tr>
<th>WHEN SHORT THE FORLER OF OR FURNER OF I</th>
<th>【行动】【<br>0</th>
</tr>
</thead>
<tbody>
<tr>
<td>M. Or Januar Make I</td>
<td></td>
</tr>
<tr>
<td>0.00</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td>Inspector<br>ロ<br>×<br>ក</td>
<td></td>
</tr>
<tr>
<td>a !<br>@ Inspector</td>
<td></td>
</tr>
<tr>
<td>Mobila_Low (Universal Render Pipeline Asset)<br>01<br>0</td>
<td></td>
</tr>
<tr>
<td>Open</td>
<td></td>
</tr>
<tr>
<td>Rendering<br>1</td>
<td></td>
</tr>
<tr>
<td>Renderer List</td>
<td></td>
</tr>
<tr>
<td>0 Mobile_Low_Renderer (Universal Renderer Data)<br>O Default.</td>
<td></td>
</tr>
<tr>
<td>1   Mobile_Low_ScreenRenderer (Universal Renderer Data)<br>Set Default</td>
<td></td>
</tr>
<tr>
<td>2 Cockpit_Renderer (Universal Renderer Data)<br>6 Set Default</td>
<td></td>
</tr>
<tr>
<td>+ -</td>
<td></td>
</tr>
<tr>
<td>ਤੇ<br>Depth Texture</td>
<td></td>
</tr>
<tr>
<td>Opaque Texture</td>
<td></td>
</tr>
<tr>
<td>Opaque Downsampong<br>2x Billnear</td>
<td></td>
</tr>
<tr>
<td>Terrain Holes<br>GPU Resident Drawer<br>Disabled</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td>Quality<br>HOR</td>
<td></td>
</tr>
<tr>
<td>Disabled<br>Anti Allesing (MSAA)</td>
<td></td>
</tr>
<tr>
<td>0.8<br>Render Scale</td>
<td></td>
</tr>
<tr>
<td>FidelityFX Super Resolution 1.0<br>Upscaling Fiter<br>8</td>
<td></td>
</tr>
<tr>
<td>Override FSR Sharpness<br>LOD Cross Fade</td>
<td></td>
</tr>
<tr>
<td>Blue Nolse<br>LOD Cress Fade Ditthering Type</td>
<td></td>
</tr>
<tr>
<td>Lighting</td>
<td></td>
</tr>
<tr>
<td>Per Pixel<br>Main Light</td>
<td></td>
</tr>
<tr>
<td>Cast Shadows<br>V</td>
<td></td>
</tr>
<tr>
<td>512<br>Shadow Resolution</td>
<td></td>
</tr>
<tr>
<td>Light Probe System<br>Light Probe Groups</td>
<td></td>
</tr>
<tr>
<td>Additional Lights<br>Per Pixel</td>
<td></td>
</tr>
<tr>
<td>Per Object Limit<br>Cast Shadows</td>
<td></td>
</tr>
<tr>
<td>Shadow Allies Resolution<br>2048</td>
<td></td>
</tr>
<tr>
<td>Shedow Resolution Timm<br>Medium 512<br>Low 256<br>High 1024</td>
<td></td>
</tr>
<tr>
<td>512<br>Cookie Atlas Resolution</td>
<td></td>
</tr>
<tr>
<td>Cookie Atlas Format<br>Grayscale Low</td>
<td></td>
</tr>
<tr>
<td>Reflection Probes</td>
<td></td>
</tr>
<tr>
<td>Asset Labels</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td>AssetBundle None<br>· None</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td>8 1000 8</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
</tr>
</tbody>
</table>
<p>Render pipeline asset</p>
<h1 id="-span-id-page-10-1-span-span-id-page-10-0-span-profiling-tips"><span id="page-10-1"></span><span id="page-10-0"></span>Profiling tips</h1>
<h2 id="profile-early-often-and-on-the-target-device">Profile early, often, and on the target device</h2>
<p>Profiling is the process of measuring aspects of your game&#39;s performance at runtime and to track down the cause of a performance problem. By monitoring the profiling tool as you make changes, you can gauge whether changes actually fix the performance problem.</p>
<p><img src="_page_10_Picture_3.jpeg" alt=""></p>
<p><span id="page-11-0"></span><img src="_page_11_Picture_0.jpeg" alt=""></p>
<p>For mobile, XR, and web projects, it&#39;s crucial to profile your application early and throughout the development cycle, not just when you&#39;re nearing launch. Address performance issues such as glitches or spikes as soon as they appear, and benchmark performance before and after major changes. By developing a clear &quot;performance profile&quot; for your project, you can more easily identify and resolve new issues, ensuring optimal performance across all target platforms.</p>
<p>While profiling in the Editor can give you an idea of the relative performance of different systems in your game, profiling on each device gives you the opportunity to gain more accurate insights. Profile a development build on target devices whenever possible. Remember to profile and optimize for both the highest- and lowest-spec devices that you plan to support.</p>
<p>Unity offers a suite of profiling tools to help identify bottlenecks including</p>
<p>the <a href="https://docs.unity3d.com/6000.0/Documentation/Manual/Profiler.html?">Unity Profiler,</a> the <a href="https://docs.unity3d.com/Packages/com.unity.memoryprofiler@1.1/manual/index.html">Memory Profiler</a> and <a href="https://docs.unity3d.com/Packages/com.unity.performance.profile-analyzer@1.2/manual/index.html">Profile Analyzer</a>. There are also native tools from iOS and Android for further performance testing on their respective hardware:</p>
<ul>
<li>On iOS, use <a href="https://developer.apple.com/documentation/xcode/">Xcode</a> and <a href="https://help.apple.com/instruments/mac/current/#/dev7b09c84f5">Instruments</a>.</li>
<li>On Android / Arm use:<ul>
<li><a href="https://developer.android.com/studio/profile">Android Studio</a>: The latest Android Studio includes a new <a href="https://developer.android.com/studio/profile/android-profiler">Android Profiler</a> that replaces the previous Android Monitor tools. Use it to gather real-time data about hardware resources on Android devices.</li>
<li><a href="https://developer.arm.com/tools-and-software/graphics-and-gaming/arm-mobile-studio">Arm Mobile Studio:</a> This suite of tools can help you profile and debug your games in great detail, catering toward devices running Arm hardware.</li>
<li><a href="https://developer.qualcomm.com/software/snapdragon-profiler">Snapdragon Profiler</a>: Specifically for Snapdragon chipset devices only. Analyze CPU, GPU, DSP, memory, power, thermal, and network data to help find and fix performance bottlenecks.</li>
<li><a href="https://developers.meta.com/horizon/resources/developer-tools/#performance-monitoring-and-profiling-tools">Developer tools for Meta Quest</a>: See Meta&#39;s developer tools website for information about developing apps for Meta Quest headsets.</li>
</ul>
</li>
</ul>
<p>Certain hardware can also take advantage of <a href="https://software.intel.com/en-us/intel-vtune-amplifier-xe">Intel VTune,</a> which helps you to find and fix performance bottlenecks on Intel platforms (with Intel processors only).</p>
<h3 id="focus-on-optimizing-the-right-areas">Focus on optimizing the right areas</h3>
<p>Don&#39;t guess or make assumptions about what is slowing down your game&#39;s performance. Use the Unity Profiler and platform-specific tools to locate the precise source of a lag. Profiling tools ultimately help you understand what&#39;s going on under the hood of your Unity project, but don&#39;t wait for significant performance problems to start showing before digging into your detective toolbox.</p>
<p>Of course, not every optimization described here will apply to your application. Something that works well in one project may not translate to yours. Identify genuine bottlenecks and concentrate your efforts on what benefits your work. To learn more about how to plan your profiling workflows see the <em><a href="https://resources.unity.com/games/ultimate-guide-to-profiling-unity-games?ungated=true">Ultimate guide to profiling Unity games</a></em>.</p>
<p><img src="_page_12_Picture_1.jpeg" alt=""></p>
<p><img src="_page_12_Figure_2.jpeg" alt=""></p>
<p>A chart from the profiling e-book featuring a workflow you can follow to profile your Unity projects efficiently</p>
<p><span id="page-13-0"></span><img src="_page_13_Picture_0.jpeg" alt=""></p>
<h2 id="understand-how-the-unity-profiler-works">Understand how the Unity Profiler works</h2>
<p>The <a href="https://docs.unity3d.com/6000.0/Documentation/Manual/Profiler.html">Unity Profiler</a> can help you detect the causes of any lags or freezes at runtime and better understand what&#39;s happening at a specific frame or point in time.</p>
<p>The Profiler is instrumentation-based; it profiles timings of game and engine code that are automatically marked up (such as MonoBehaviour&#39;s Start or Update methods, or specific API calls), or explicitly wrapped with the help of <a href="https://docs.unity3d.com/6000.0/Documentation/ScriptReference/Unity.Profiling.ProfilerMarker.html?">ProfilerMarker</a> API.</p>
<p>Begin by enabling the CPU and Memory tracks as your default. You can monitor supplementary Profiler Modules like Renderer, Audio, and Physics, as needed for your game (e.g., physics-heavy or music-based gameplay).</p>
<p><img src="_page_13_Figure_6.jpeg" alt=""></p>
<p>Use the Unity Profiler to test performance and resource allocation for your application.</p>
<p>To capture profiling data from an actual mobile device within your chosen platform, check the <strong>Development Build</strong> and <strong>Autoconnect Profiler</strong> boxes before you click <strong>Build and Run</strong>. Alternatively, if you want the app to start separately from your profiling, you can uncheck the <strong>Autoconnect Profiler</strong> box, and then connect manually once the app is running.</p>
<p><img src="_page_14_Picture_0.jpeg" alt=""></p>
<p><img src="_page_14_Picture_1.jpeg" alt=""></p>
<p>Adjust your Build Settings before profiling.</p>
<p>Choose the platform target to profile. The <strong>Record</strong> button tracks several seconds of your application&#39;s playback (300 frames by default). Go to <strong>Unity &gt; Preferences &gt; Analysis &gt; Profiler &gt; Frame Count</strong> to increase this as far as 2000 if you need longer captures. While this means that the Unity Editor has to do more CPU work and take up more memory, it can be useful depending on your specific scenario.</p>
<p><img src="_page_15_Figure_1.jpeg" alt=""></p>
<p>Use the Timeline view to determine if you are CPU-bound or GPU-bound.</p>
<p>If you need in-depth analysis capturing detailed information about your application you can also use the <a href="https://docs.unity3d.com/6000.0/Documentation/Manual/ProfilerWindow.html#deep-profiling">Deep Profiling</a> setting. This enables Unity to profile the beginning and end of every function call in your script code, telling you exactly which part of your application is being executed and potentially causing a delay. However, deep profiling adds overhead to every method call and may skew the performance analysis as it slows down the execution of your game during the profiling session.</p>
<p>Click in the window to analyze a specific frame. Next, use either the <strong>Timeline</strong> or <strong>Hierarchy</strong> view for the following:</p>
<ul>
<li>Timeline shows the visual breakdown of timing for a specific frame. This allows you to visualize how the activities relate to one another and across different threads. Use this option to determine if you are CPU- or GPU-bound:<ul>
<li>If the CPU frame time is significantly higher than the GPU frame time, your game is CPU-bound. This means the CPU is taking longer to process the game logic, physics, or other calculations, and the GPU is waiting for the CPU to finish its tasks.</li>
<li>Similarly, if the GPU frame time is higher than the CPU frame time, your game is GPU-bound. This indicates that the GPU is taking longer to render graphics, and the CPU is waiting for the GPU to finish rendering.</li>
</ul>
</li>
</ul>
<p><img src="_page_16_Picture_0.jpeg" alt=""></p>
<p>— The Timeline Hierarchy shows the hierarchy of ProfileMarkers, grouped together. This allows you to sort the samples based on time cost in milliseconds (<strong>Time ms</strong> and S<strong>elf ms</strong>). You can also count the number of Calls to a function and the managed heap memory (GC Alloc) on the frame. By sorting by Time ms or Self ms, you can then identify the functions that are taking the most time, either on their own or due to the functions they call. This helps you focus your optimization efforts on the areas that will give the biggest performance gains.</p>
<table>
<thead>
<tr>
<th>0</th>
<th></th>
<th>Profiler</th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>Co Profiler</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Profiler Modules<br>S. CPU Usage</td>
<td>- Playmode - @ 14 DI Frame: 145/300 Clear<br>66ms (15FPS)</td>
<td>Clear on Play Deep Profile Call Stacks ▼</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>Selected: Gfx.WaitForPresentOnGfxThread</td>
<td>0 2 2 0</td>
<td></td>
</tr>
<tr>
<td>· Rendering</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>· Scripts<br>· Physics</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>· Animation</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>GarbageCollector<br>· VSync</td>
<td>33ms [30FPS</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>· Global Illumination<br>u Ul</td>
<td>16ms (60FPS)</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Others</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td>1.17ms</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>C Memory</td>
<td></td>
<td>368.6 MB<br>36.5 MB</td>
<td>110.4 MB<br>164</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Total Used Memory<br>· Texture Memory</td>
<td></td>
<td>11.22k</td>
<td>5.1 MB</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>· Mesh Memory<br>· Material Count</td>
<td></td>
<td>5,9 KB</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Object Count<br>GC Used Memory</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>GC Allocated In Frame</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Hierarchy</td>
<td>· Live Main Thread</td>
<td>CPU:36:30ms GPU :- - ms</td>
<td></td>
<td>ರ</td>
<td></td>
<td></td>
<td></td>
<td>No Detaills</td>
<td></td>
<td>7 1</td>
</tr>
<tr>
<td>Overview</td>
<td></td>
<td></td>
<td></td>
<td>Total</td>
<td>Self</td>
<td>Calls</td>
<td>GC Alloc</td>
<td>Time ms</td>
<td>Self ms</td>
<td>A</td>
</tr>
<tr>
<td>v PlayerLoop<br>&gt; WaitForTargetFPS</td>
<td></td>
<td></td>
<td></td>
<td>99.9%<br>66.7%</td>
<td>0.0%<br>66.7%</td>
<td>1<br>13</td>
<td>5.9KB<br>0 B</td>
<td>36.28<br>24.24</td>
<td>0.02<br>24.23</td>
<td></td>
</tr>
<tr>
<td>T PostLateUpdate.FinishFrameRendering</td>
<td></td>
<td></td>
<td></td>
<td>25.9%</td>
<td>0.1%</td>
<td>1</td>
<td>32 B</td>
<td>9,41</td>
<td>0.04</td>
<td></td>
</tr>
<tr>
<td>- Gfx.WaitForPresentOnGlxThread</td>
<td>&gt; RenderPipelineManager.DoRenderLoop_Internal()</td>
<td></td>
<td></td>
<td>22.0%<br>3.2%</td>
<td>0.0%<br>0.0%</td>
<td>13<br>12</td>
<td>328<br>08</td>
<td>8.00<br>1.17</td>
<td>0.00<br>0.00</td>
<td></td>
</tr>
<tr>
<td>&gt; Destroy CullResults</td>
<td></td>
<td></td>
<td></td>
<td>0.3%</td>
<td>0.0%</td>
<td>2</td>
<td>OB</td>
<td>0.11</td>
<td>0.03</td>
<td></td>
</tr>
<tr>
<td>&gt; UlEvents.CanvasManagerRenderOverlays</td>
<td></td>
<td></td>
<td></td>
<td>0.1%</td>
<td>0.0%</td>
<td>12</td>
<td>0 8</td>
<td>0.04</td>
<td>0.00</td>
<td></td>
</tr>
<tr>
<td></td>
<td>TickReRuntimeRellectionSystemWapperInternal ScriptobleRunimeReflectionSystemMrapper_TickRealtimeProbes()</td>
<td></td>
<td></td>
<td>0.0%</td>
<td>0.0%</td>
<td>13</td>
<td>OB</td>
<td>0.01</td>
<td>0.00</td>
<td></td>
</tr>
<tr>
<td>&gt; ReflectionProbes.Update</td>
<td></td>
<td></td>
<td></td>
<td>0.0%<br>0.0%</td>
<td>0.0%</td>
<td>12<br>13</td>
<td>OB<br>OB</td>
<td>0.01<br>0.01</td>
<td>0.01<br>0.00</td>
<td></td>
</tr>
<tr>
<td>&gt; WatermarkRender<br>&gt; UlEvents IMGUIRenderOverlays</td>
<td></td>
<td></td>
<td></td>
<td>0.0%</td>
<td>0.0%<br>0.0%</td>
<td>13</td>
<td>OB</td>
<td>0.00</td>
<td>0.00</td>
<td></td>
</tr>
<tr>
<td></td>
<td>SupportedRenderingFeatures.isUlOverlayRenderecBySRP()</td>
<td></td>
<td></td>
<td>0.0%</td>
<td>0.0%</td>
<td>17</td>
<td>OB</td>
<td>0.00</td>
<td>0.00</td>
<td></td>
</tr>
<tr>
<td>Camera Render</td>
<td></td>
<td></td>
<td></td>
<td>0.0%</td>
<td>0.0%</td>
<td>1</td>
<td>08</td>
<td>0.00</td>
<td>0.00</td>
<td></td>
</tr>
<tr>
<td>End Graphics Jobs</td>
<td></td>
<td></td>
<td></td>
<td>0.0%</td>
<td>0.0%</td>
<td>2</td>
<td>OB</td>
<td>0.00</td>
<td>0.00</td>
<td></td>
</tr>
<tr>
<td>&gt; Update. ScriptRunBehaviourUpdate</td>
<td></td>
<td></td>
<td></td>
<td>1.3%</td>
<td>0.0%</td>
<td>17</td>
<td>5.3 KB</td>
<td>0.49</td>
<td>0.00</td>
<td></td>
</tr>
<tr>
<td>FixedUpdate.PhysicsFixedUpdate<br>&gt; PreLateUpdate.ScriptRunBehaviourLateUpdate</td>
<td></td>
<td></td>
<td></td>
<td>1.0%<br>0.9%</td>
<td>0.0%<br>0.0%</td>
<td>13<br>13</td>
<td>OB<br>0.6KB</td>
<td>0.38<br>0.33</td>
<td>0.01<br>0.00</td>
<td></td>
</tr>
<tr>
<td>FixedUpdate.ScriptRunBehavlourFixedUpdate</td>
<td></td>
<td></td>
<td></td>
<td>0.8%</td>
<td>0.0%</td>
<td>1</td>
<td>08</td>
<td>0.31</td>
<td>0.00</td>
<td></td>
</tr>
<tr>
<td>PostLateUpdate.Update.UpdateAllRenderers</td>
<td></td>
<td></td>
<td></td>
<td>0.7%</td>
<td>0.0%</td>
<td>1</td>
<td>08</td>
<td>0.25</td>
<td>0.00</td>
<td></td>
</tr>
<tr>
<td>&gt; PreLateUpdate.ParticleSystemBeginUpdateAll</td>
<td></td>
<td></td>
<td></td>
<td>0.4%</td>
<td>0.0%</td>
<td>16</td>
<td>OB</td>
<td>0.16</td>
<td>0.00</td>
<td></td>
</tr>
<tr>
<td>PostLateUpdate.ProfilerEndFrame</td>
<td></td>
<td></td>
<td></td>
<td>0.2%</td>
<td>0.0%</td>
<td>12</td>
<td>OB</td>
<td>0.09</td>
<td>0.00</td>
<td></td>
</tr>
<tr>
<td>I PostLateUpdate.UpdateAudio</td>
<td></td>
<td></td>
<td></td>
<td>0.2%<br>0.1%</td>
<td>0.0%</td>
<td>13<br>11</td>
<td>OB<br>OB</td>
<td>0.09<br>0.07</td>
<td>0.00<br>0.00</td>
<td></td>
</tr>
<tr>
<td>PostLateUpdate.ParticleSystemEndUpdateAll<br>&gt; Early Update . Update Texture Streaming Manager</td>
<td></td>
<td></td>
<td></td>
<td>0.1%</td>
<td>0.0%<br>0.0%</td>
<td>1</td>
<td>OB</td>
<td>0.04</td>
<td>0.00</td>
<td></td>
</tr>
<tr>
<td>&gt; FixedUpdate.AudioFixedUpdate</td>
<td></td>
<td></td>
<td></td>
<td>0.1%</td>
<td>0.0%</td>
<td>13</td>
<td>OB</td>
<td>0.04</td>
<td>0.00</td>
<td></td>
</tr>
<tr>
<td>PreLateUpdate.AlUpdatePostScript</td>
<td></td>
<td></td>
<td></td>
<td>0.0%</td>
<td>0.0%</td>
<td>1.</td>
<td>OB</td>
<td>0.03</td>
<td>0.00</td>
<td></td>
</tr>
<tr>
<td>&gt; PostLateUpdate.PlayerUpdateCanvases</td>
<td></td>
<td></td>
<td></td>
<td>0.0%</td>
<td>0.0%</td>
<td></td>
<td>0 8</td>
<td>0.02</td>
<td>0.00</td>
</tr>
</tbody>
</table>
<p>The Hierarchy view allows you to sort ProfileMarkers by time cost.</p>
<p>You can find a complete overview of the Unity Profiler <a href="https://resources.unity.com/games/ultimate-guide-to-profiling-unity-games?ungated=true">here.</a> If you&#39;re new to profiling, you can also watch this <a href="https://youtube.com/watch?v=xjsqv8nj0cw">Introduction to Unity Profiling.</a></p>
<p>Before optimizing anything in your project, save the Profiler .data file. Implement your changes and compare the saved .data before and after the modification. Rely on this cycle to improve performance: profile, optimize, and compare. Then, rinse and repeat.</p>
<p><span id="page-17-0"></span><img src="_page_17_Picture_0.jpeg" alt=""></p>
<h2 id="use-the-profile-analyzer">Use the Profile Analyzer</h2>
<p>The Profile Analyzer lets you aggregate multiple frames of Profiler data and then locate frames of interest. Do you want to see what happens to the Profiler after you make a change to your project? The <strong>Compare</strong> view allows you to load and differentiate two data sets, so you can test changes and improve their outcome. The <a href="https://docs.unity3d.com/Packages/com.unity.performance.profile-analyzer@1.2/manual/index.html">Profile Analyzer</a> is available via Unity&#39;s Package Manager. <a href="https://www.youtube.com/watch?v=Ypg84Fr20Sw&amp;t=1s">Watch this Profile Analyzer tutorial</a> to learn more about its features.</p>
<table>
<thead>
<tr>
<th>Profile Analyzer</th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th>: ロ×</th>
</tr>
</thead>
<tbody>
<tr>
<td>Mode: Single Compare Export Close Profiler Window</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Pull Data</td>
<td>117.77ms ▼</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>Frame Summary</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Load Save VikingVillage_Left_MacPlayer_Wind</td>
<td>0.00ms</td>
<td>33.00ms</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>Left</td>
<td>Right</td>
<td>Diff</td>
<td></td>
</tr>
<tr>
<td>Pull Data</td>
<td></td>
<td></td>
<td></td>
<td>184 [262] 445</td>
<td></td>
<td></td>
<td></td>
<td>999</td>
<td>Frame Count</td>
<td>262</td>
<td>262</td>
<td>O</td>
<td></td>
</tr>
<tr>
<td></td>
<td>117.77ms ▼</td>
<td>33.00ms</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>Start</td>
<td>184</td>
<td>184</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Load<br>Save VikingVillage_Right_MacPlayer_Win</td>
<td>0.00ms</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>999</td>
<td>End</td>
<td>445</td>
<td>445</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>&gt; a Pair Graph Selection</td>
<td></td>
<td></td>
<td>184 [262] 445</td>
<td></td>
<td></td>
<td></td>
<td>PlayerLoop</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>ms</td>
<td>ms</td>
<td>ms</td>
<td></td>
</tr>
<tr>
<td>v Filters</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>Max</td>
<td>22.91</td>
<td>16.10</td>
<td>-6.80</td>
<td></td>
</tr>
<tr>
<td>None<br>&gt;<br>Remove :</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>Upper Quartile</td>
<td>16.61</td>
<td>12.05</td>
<td>-4.56</td>
<td></td>
</tr>
<tr>
<td>All ▼<br>Name Filter :</td>
<td></td>
<td>Exclude Names: Any ▼</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>Median</td>
<td>15.63</td>
<td>11.35</td>
<td>-4.28</td>
<td></td>
</tr>
<tr>
<td>Select Main Thread<br>Thread :</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>Mean</td>
<td>15,90</td>
<td>11.60</td>
<td>-4.30</td>
<td></td>
</tr>
<tr>
<td>Depth Slice :<br>All - - - Auto Depth (Diff: None)</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>Analysis Type : Total</td>
<td></td>
<td></td>
<td>Lower Quartile</td>
<td>14.90</td>
<td>10.80</td>
<td>-4.10</td>
<td></td>
</tr>
<tr>
<td>Parent Marker :<br>Clear PlayerLoop</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>Units : Milliseconds</td>
<td></td>
<td>&gt;</td>
<td>Min</td>
<td>13.71</td>
<td>9.62</td>
<td>-4.10</td>
<td></td>
</tr>
<tr>
<td>494 of 554 markers , 1 of 47 threads<br>Compare</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>Marker Columns : Time and Count</td>
<td></td>
<td>&gt;</td>
<td></td>
<td></td>
<td></td>
<td>22.905</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Top 10 markers on median frames</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>0</td>
<td></td>
</tr>
<tr>
<td>219<br>PlayerLoop<br>FinishFrameRe Render</td>
<td>GBuffer</td>
<td>Drawing Opaqı</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>94.1ms</td>
<td>O</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>FinishFrameR Render<br>292<br>PlayerLoop</td>
<td>GBuffer</td>
<td>Drawing Opaqı Cu</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>65.0ms</td>
<td>Thread Summary</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>(All depths)</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>Ratio : Normalized</td>
<td></td>
<td></td>
<td>Left</td>
<td>Right</td>
<td>Total</td>
<td></td>
</tr>
<tr>
<td>Marker Comparison for currently selected range</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>Total Count :</td>
<td>47</td>
<td>47</td>
<td>47</td>
<td></td>
</tr>
<tr>
<td>Marker Name</td>
<td>Left Mer &lt;</td>
<td>15</td>
<td>Right Mc Diff</td>
<td></td>
<td></td>
<td>Abs Diff   Count L   Count R   Count D</td>
<td></td>
<td></td>
<td>Unique Count :</td>
<td>O</td>
<td>0</td>
<td>O</td>
<td></td>
</tr>
<tr>
<td>PlayerLoop</td>
<td>15.60</td>
<td></td>
<td>11,31</td>
<td>-4.29</td>
<td>4.29</td>
<td>262</td>
<td>262</td>
<td>0</td>
<td>Selected :</td>
<td>1</td>
<td></td>
<td>1</td>
<td></td>
</tr>
<tr>
<td>PostLateUpdate.FinishFrameRendering</td>
<td>12.14</td>
<td></td>
<td>8.02</td>
<td>-4.12</td>
<td>4.12</td>
<td>262</td>
<td>262</td>
<td>0</td>
<td>Graph Scale :</td>
<td>Upper quartile</td>
<td></td>
<td>&gt;</td>
<td></td>
</tr>
<tr>
<td>Camera. Render</td>
<td>11,60</td>
<td></td>
<td>7.57</td>
<td>-4.04</td>
<td>4.04</td>
<td>262</td>
<td>262</td>
<td>0</td>
<td></td>
<td>Median</td>
<td>Thread</td>
<td></td>
<td></td>
</tr>
<tr>
<td>RenderDeferred. GBuffer</td>
<td>9.76</td>
<td></td>
<td>5,78</td>
<td>-3.98</td>
<td>3.98</td>
<td>524</td>
<td>524</td>
<td>0</td>
<td></td>
<td>-0 15.60</td>
<td>Main Thread</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Drawing</td>
<td>7.85</td>
<td></td>
<td>4.80</td>
<td>-3.05</td>
<td>3.05</td>
<td>524</td>
<td>524</td>
<td>0</td>
<td>-11.31</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Render. Opaque Geometry</td>
<td>6.06</td>
<td></td>
<td>3.65</td>
<td>-2.41</td>
<td>2.41</td>
<td>524</td>
<td>524</td>
<td>0</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>BatchRenderer.Flush</td>
<td>1.41</td>
<td></td>
<td>0.61</td>
<td>-0.80</td>
<td>0.80</td>
<td>45512</td>
<td>24812</td>
<td>-20700</td>
<td>Marker Summary<br>PlayerLoop</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>WaitForJobGroupID</td>
<td>2.02</td>
<td></td>
<td>1.23</td>
<td>-0.79</td>
<td>0.79</td>
<td>3 අවශ්‍ය</td>
<td>3622</td>
<td>-377</td>
<td>Mean frame contribution</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>RenderForward.RenderLoopJob</td>
<td>0.94</td>
<td></td>
<td>0.38</td>
<td>-0.56</td>
<td>0.56</td>
<td>524</td>
<td>524</td>
<td>0</td>
<td></td>
<td>Left</td>
<td>Right</td>
<td>Diff</td>
<td></td>
</tr>
<tr>
<td>Culling</td>
<td>2.49</td>
<td></td>
<td>1.93</td>
<td>-0.56</td>
<td>0.56</td>
<td>524</td>
<td>524</td>
<td>0</td>
<td></td>
<td>99.79%</td>
<td>99.65%</td>
<td>-0.14%</td>
<td></td>
</tr>
<tr>
<td>Render. TransparentGeometry</td>
<td>0.98</td>
<td></td>
<td>0.48</td>
<td>-0.50</td>
<td>0.50</td>
<td>524</td>
<td>524</td>
<td>0</td>
<td>First frame</td>
<td>184</td>
<td>184</td>
<td></td>
<td></td>
</tr>
<tr>
<td>RenderForwardAlpha.Render</td>
<td>0.71</td>
<td></td>
<td>0.28</td>
<td>-0.43</td>
<td>0.43</td>
<td>524</td>
<td>524</td>
<td>0</td>
<td>Top 3 ▼ by frame costs</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Cull Results. Create Shared Renderer Scene</td>
<td>1.01</td>
<td></td>
<td>0.66</td>
<td>-0.35</td>
<td>0.35</td>
<td>524</td>
<td>524</td>
<td>0</td>
<td></td>
<td>22.87</td>
<td>16.07</td>
<td>-6.81</td>
<td></td>
</tr>
<tr>
<td>SceneCulling</td>
<td>1.34</td>
<td></td>
<td>1.05</td>
<td>-0.28</td>
<td>0.28</td>
<td>524</td>
<td>524</td>
<td>0</td>
<td></td>
<td>21.73</td>
<td>15.05</td>
<td>-6.68</td>
<td></td>
</tr>
<tr>
<td>CullSendEvents<br>Terrain Details Render</td>
<td>1.22<br>0.85</td>
<td></td>
<td>0.95<br>0:59</td>
<td>-0.27<br>-0.25</td>
<td>0.27<br>0.25</td>
<td>524<br>262</td>
<td>524<br>262</td>
<td>0<br>0</td>
<td></td>
<td>20.64</td>
<td>14.87</td>
<td>-5.76</td>
<td></td>
</tr>
<tr>
<td>EndRenderQueueExtraction</td>
<td>0.78</td>
<td></td>
<td>0.54</td>
<td>-0.25</td>
<td>0.25</td>
<td>524</td>
<td>524</td>
<td>0</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>ExecuteRenderQueueJob</td>
<td>0.36</td>
<td></td>
<td>0.14</td>
<td>-0.21</td>
<td>0.21</td>
<td>319</td>
<td>301</td>
<td>-18</td>
<td></td>
<td></td>
<td></td>
<td>22.871</td>
<td></td>
</tr>
<tr>
<td>Assembly-CSharp-firstpass.dll !:: Water Tile. On Will Ren&lt; 0.99</td>
<td></td>
<td></td>
<td>0.79</td>
<td>-0.20</td>
<td>0.20</td>
<td>262</td>
<td>262</td>
<td>0</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Camera. Custom Render</td>
<td>0.90</td>
<td></td>
<td>0.71</td>
<td>-0.20</td>
<td>0.20</td>
<td>262</td>
<td>262</td>
<td>0</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Batch.DrawDynamic</td>
<td>0.21</td>
<td></td>
<td>0.06</td>
<td>-0.15</td>
<td>0.15</td>
<td>9956</td>
<td>2620</td>
<td>-7336</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Render.Mesh</td>
<td>0.27</td>
<td></td>
<td>0.13</td>
<td>-0.14</td>
<td>0.14</td>
<td>112922</td>
<td>52924</td>
<td>-59998</td>
<td></td>
<td></td>
<td></td>
<td>9,5831</td>
<td></td>
</tr>
<tr>
<td>RenderForwardOpaque.Render</td>
<td>0.30</td>
<td></td>
<td>0.17</td>
<td>-0.13</td>
<td>0.13</td>
<td>262</td>
<td>262</td>
<td>0</td>
<td>9.5831</td>
<td>22,871</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Flare.Render</td>
<td>0.29</td>
<td></td>
<td>0.16</td>
<td>-0.13</td>
<td>0.13</td>
<td>262</td>
<td>262</td>
<td>0</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Queue Prepare Integrate Main Thread Objects</td>
<td>0.19</td>
<td></td>
<td>0.07</td>
<td>-0.13</td>
<td>0.13</td>
<td>524</td>
<td>524</td>
<td>0</td>
<td></td>
<td>ms</td>
<td>ms</td>
<td>ms</td>
<td></td>
</tr>
<tr>
<td>Destroy CullResults</td>
<td>0.22</td>
<td></td>
<td>0.10</td>
<td>-0.12</td>
<td>0.12</td>
<td>524</td>
<td>524</td>
<td>0</td>
<td>Max</td>
<td>22.87</td>
<td>16.07</td>
<td>-6.81</td>
<td></td>
</tr>
<tr>
<td>RenderLoop. CleanupNodeQueue</td>
<td>0.20</td>
<td></td>
<td>0.08</td>
<td>-0.12</td>
<td>0.12</td>
<td>3668</td>
<td>3668</td>
<td>0</td>
<td>Upper Quartile</td>
<td>16.57</td>
<td>12.00</td>
<td>-4.57</td>
<td></td>
</tr>
<tr>
<td>CullPerObjectLights</td>
<td>0.17</td>
<td></td>
<td>0.07</td>
<td>-0.10</td>
<td>0.10</td>
<td>524</td>
<td>524</td>
<td>0</td>
<td>Median</td>
<td>15.60</td>
<td>11.31</td>
<td>-4.29</td>
<td></td>
</tr>
<tr>
<td>ComputeNeedsPerObjectLights</td>
<td>0.16</td>
<td></td>
<td>0.07</td>
<td>-0.09</td>
<td>0.09</td>
<td>524</td>
<td>524</td>
<td>0</td>
<td>Mean</td>
<td>15.87</td>
<td>11.56</td>
<td>-4.31</td>
<td></td>
</tr>
<tr>
<td>Update. ScriptRunBehaviourUpdate</td>
<td>0.44</td>
<td></td>
<td>0.35</td>
<td>-0.08</td>
<td>0.08</td>
<td>262</td>
<td>262</td>
<td>O</td>
<td>Lower Quartile</td>
<td>14.87</td>
<td>10.77</td>
<td>-4.11</td>
<td></td>
</tr>
<tr>
<td>BehaviourUpdate</td>
<td>0.43</td>
<td></td>
<td>0.35</td>
<td>-0.08</td>
<td>0.08</td>
<td>262</td>
<td>262</td>
<td>0</td>
<td>Min</td>
<td>13.68</td>
<td>9.58</td>
<td>-4.09</td>
<td></td>
</tr>
<tr>
<td>ParticleSystem.Draw</td>
<td>0.09</td>
<td></td>
<td>0.03</td>
<td>-0.07</td>
<td>0.07</td>
<td>6474</td>
<td>2280</td>
<td>-4194</td>
<td>Individual Max</td>
<td>22.87</td>
<td>16.07</td>
<td>-6.81</td>
<td></td>
</tr>
<tr>
<td>RenderDeferred.Lighting</td>
<td>0.14</td>
<td></td>
<td>0.07</td>
<td>-0.06</td>
<td>0.06</td>
<td>262</td>
<td>262</td>
<td>0</td>
<td>Individual Min</td>
<td>13.68</td>
<td>9.58</td>
<td>-4.09</td>
<td></td>
</tr>
<tr>
<td>Dandar Dransro</td>
<td>019</td>
<td></td>
<td>000</td>
<td>-0 00</td>
<td>000</td>
<td>601</td>
<td>62/</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>Take an even deeper dive into frames and marker data with the Profile Analyzer, which complements the existing Profiler.</p>
<h2 id="work-on-a-specific-time-budget-per-frame">Work on a specific time budget per frame</h2>
<p>Each frame will have a time budget based on your target frames per second (fps). For an application to run at 30 fps, its frame budget can&#39;t exceed 33.33 ms per frame (1000 ms/30 fps). Likewise, a target of 60 fps leaves 16.66 ms per frame (1000 / 60 fps).</p>
<p>When developing virtual reality (VR) apps, maintaining a high and stable frame rate is even more critical to ensure a smooth and immersive experience, and to prevent motion sickness. The most common target for VR applications is 90 fps, which gives you a strict frame budget</p>
<p><span id="page-18-0"></span><img src="_page_18_Picture_0.jpeg" alt=""></p>
<p>of just 11.11 ms per frame (1000 ms / 90 fps). This higher requirement is necessary because VR needs to render each frame twice—once for each eye—and small imperfections in timing can be far more noticeable to the user.</p>
<p>A consistent and high frame rate is also essential for Unity Web Builds, the performance of which is highly dependent on the browser&#39;s efficiency and the hardware capabilities. A tight time budget per frame remains a critical factor. For example, if you&#39;re targeting 60 fps in a Unity WebGL build, you still have only 16.66 ms per frame to work with. This budget includes all aspects of rendering, physics calculations, and game logic, which means that optimizing every part of your application is crucial. Efficient management of assets, reducing the complexity of scenes, and optimizing shaders and scripts are all necessary steps to ensure that your application can meet its performance targets.</p>
<p>It&#39;s also important to consider the impact of WebAssembly (Wasm) performance, which Unity uses to compile and run your code in the browser. While Wasm offers significant performance improvements over traditional JavaScript, it&#39;s still important to profile and optimize your code to ensure that you&#39;re making the most of the available frame time.</p>
<h3 id="account-for-device-temperature">Account for device temperature</h3>
<p>For mobile, however, it&#39;s generally not recommended to use this maximum time consistently as the device can overheat and the OS can thermal throttle the CPU and GPU. A general rule of thumb is use only about 65% of the available time to allow for cooldown between frames. A typical frame budget will be approximately 22 ms per frame at 30 fps and 11 ms per frame at 60 fps.</p>
<p>Devices can exceed this budget for short periods of time (e.g., for cutscenes or loading sequences) but not for a prolonged duration.</p>
<p>Most mobile devices do not have active cooling like their desktop counterparts. Physical heat levels can directly impact performance.</p>
<p>If the device is running hot, the Profiler might perceive and report poor performance, even if it is not cause for long-term concern. To combat profiling overheating, profile in short bursts. This cools the device and simulates real-world conditions. Our general recommendation is to keep the device cool for 10-15 minutes before profiling again.</p>
<h2 id="determine-if-you-are-gpu-bound-or-cpu-bound">Determine if you are GPU-bound or CPU-bound</h2>
<p>The central processing unit (CPU) is responsible for determining what must be drawn, and the graphics processing unit (GPU) is responsible for drawing it. When a rendering performance problem is due to the CPU taking too long to render a frame, the game becomes CPU bound. When a rendering performance problem is due to the GPU taking too long to render a frame, it becomes GPU bound.</p>
<p><span id="page-19-0"></span><img src="_page_19_Picture_0.jpeg" alt=""></p>
<p>The Profiler can tell you if your CPU is taking longer than your allotted frame budget, or if the culprit is your GPU. It does this by emitting markers prefixed with Gfx as follows:</p>
<ul>
<li>If you see the <strong>Gfx.WaitForCommands</strong> marker, it means that the render thread is ready, but you might be waiting for a bottleneck on the main thread.</li>
<li>If you frequently encounter <strong>Gfx.WaitForPresent</strong>, it means that the main thread is ready but might be waiting for the GPU to present the frame.</li>
</ul>
<h2 id="test-on-both-min-spec-and-max-spec-devices">Test on both min-spec and max-spec devices</h2>
<p>There is a wide range of iOS and Android devices out there. We want to reiterate the importance of testing your project on the minimum and maximum device specifications that you want your application to support, whenever possible.</p>
<h2 id="-span-id-page-20-0-span-memory-management-for-xr-web-and-mobile-games"><span id="page-20-0"></span>Memory management for XR, web, and mobile games</h2>
<p>Effective memory management is crucial for ensuring smooth performance. Unity handles automatic memory management for your scripts and user-generated code, allocating small, transient data on the stack and larger, long-term data on managed or native heaps. However, the demands of XR, web, and mobile applications require a more careful approach to memory usage, as inefficient memory management can lead to performance issues such as slow frame rates, increased load times, and even application crashes. In this section, we&#39;ll explore strategies to optimize memory usage across these platforms, helping you deliver responsive and stable applications.</p>
<h2 id="efficient-memory-management">Efficient memory management</h2>
<p>To deliver smooth and responsive experiences across platforms, it&#39;s essential to carefully manage object lifecycles, minimize garbage collection overhead, and optimize asset loading strategies.</p>
<p><strong>Manage object lifecycles</strong>: Properly manage the creation and destruction of objects to prevent memory leaks and unnecessary resource usage. Use <strong>Destroy()</strong> to remove unused objects and set references to null when they are no longer needed, which can free up memory.</p>
<p><strong>Object pooling</strong>: Reuse frequently used objects, such as bullets, enemies, and UI elements, rather than creating and destroying them repeatedly. Implementing object pools can significantly reduce the overhead associated with object instantiation and destruction and save on memory resources. Read more about <a href="https://unity.com/how-to/use-object-pooling-boost-performance-c-scripts-unity">object pooling in a Unity project.</a></p>
<p><img src="_page_21_Picture_0.jpeg" alt=""></p>
<p><strong>Reduce garbage collection impact:</strong> Minimize allocations to reduce the frequency and impact of garbage collection, which can cause performance hitches. Avoid frequent allocations in update loops by preallocating arrays and lists where possible. Use value types (structs) instead of reference types (classes) when appropriate, as structs are allocated on the stack and do not contribute to garbage collection overhead.</p>
<p>Optimize asset loading with the following techniques:</p>
<ul>
<li><strong>Lazy loading</strong>: Defer the loading of resources until they are actually needed. This can facilitate faster initial load times and more efficient resource management.</li>
<li><strong>Unload unused assets</strong>: Use Resources.UnloadUnusedAssets(), to free up memory occupied by assets that are no longer needed.</li>
<li><strong>Use the Addressable Asset System</strong>: Utilize the Addressable Asset System to manage assets asynchronously at runtime. This system is particularly beneficial for web and mobile platforms, supporting remote asset hosting, dynamic content updates, and lazy loading.</li>
</ul>
<p>The garbage collector periodically identifies and deallocates unused managed heap memory. The asset garbage collection runs on demand or when you load a new scene and deallocates native objects and resources. While this runs automatically, the process of examining all the objects in the heap can cause the game to stutter or run slowly.</p>
<p>Optimizing your memory usage means being conscious of when you allocate and deallocate heap memory, and how you minimize the effect of garbage collection.</p>
<p><img src="_page_21_Figure_8.jpeg" alt=""></p>
<p>See <a href="https://docs.unity3d.com/6000.0/Documentation/Manual/performance-memory-overview.html">Understanding the managed heap</a> for more information.</p>
<p>Capture, inspect, and compare snapshots in the Memory Profiler.</p>
<p><span id="page-22-0"></span><img src="_page_22_Picture_0.jpeg" alt=""></p>
<h2 id="use-the-memory-profiler">Use the Memory Profiler</h2>
<p>The <a href="https://docs.unity3d.com/Packages/com.unity.memoryprofiler@1.1/manual/index.html">Memory Profiler package</a> takes a snapshot of your managed heap memory to help you identify problems like fragmentation and memory leaks. For a quick introduction check out this Unity <a href="https://www.youtube.com/watch?v=Uuzd39AjFWQ&amp;t">video here</a>.</p>
<p>Use the <strong>Unity Objects</strong> tab to identify areas where you can eliminate duplicate memory entries or find which objects use the most memory. The <strong>All of Memory</strong> tab displays a breakdown of all the memory in the snapshot that Unity tracks.</p>
<p>Learn how to leverage the <a href="https://docs.unity3d.com/Packages/com.unity.memoryprofiler@latest">Memory Profiler in Unity</a> for improved memory usage.</p>
<h2 id="reduce-the-impact-of-garbage-collection-gc-">Reduce the impact of garbage collection (GC)</h2>
<p>Unity uses the <a href="https://www.hboehm.info/gc/">Boehm-Demers-Weiser garbage collector</a>, which stops running your program code and only resumes normal execution once its work is complete.</p>
<p>Be aware of certain unnecessary heap allocations that can cause GC spikes:</p>
<ul>
<li><strong>Strings</strong>: In C#, strings are reference types, not value types. Reduce unnecessary string creation or manipulation if you are using them at large scale. Avoid parsing stringbased data files such as JSON and XML; store data in ScriptableObjects or formats like MessagePack or Protobuf instead. Use the <a href="https://msdn.microsoft.com/en-us/library/system.text.stringbuilder">StringBuilder</a> class if you need to build strings at runtime.</li>
<li><strong>Unity function calls</strong>: Some functions create heap allocations. Cache references to arrays rather than allocating them in the middle of a loop. Also, take advantage of certain functions that avoid generating garbage. For example, use GameObject.CompareTag instead of manually comparing a string with GameObject.tag (as returning a new string creates garbage).</li>
<li><strong>Boxing</strong>: Avoid passing a value-typed variable in place of a reference-typed variable. This creates a temporary object, and the potential garbage that comes with it implicitly converts the value type to a type object (e.g., int i = 123; object o = i). Instead, try to provide concrete overrides with the value type you want to pass in. Generics can also be used for these overrides.</li>
<li><strong>Coroutines</strong>: Though yield does not produce garbage, creating a new WaitForSeconds object does. Cache and reuse the WaitForSeconds object rather than creating it in the yield line.</li>
<li><strong>LINQ and Regular Expressions</strong>: Both of these generate garbage from behind-thescenes boxing. Avoid LINQ and Regular Expressions if performance is an issue. Write for loops and use lists as an alternative to creating new arrays.</li>
</ul>
<p>For more information, see the manual page on <a href="https://docs.unity3d.com/6000.0/Documentation/Manual/performance-garbage-collection-best-practices.html">Garbage collection best practices.</a></p>
<p><span id="page-23-0"></span><img src="_page_23_Picture_0.jpeg" alt=""></p>
<h2 id="time-garbage-collection-whenever-possible">Time garbage collection whenever possible</h2>
<p>If you are certain that a garbage collection freeze won&#39;t affect a specific point in your game, you can trigger garbage collection with <strong>System.GC.Collect</strong>.</p>
<p>See <a href="https://docs.unity3d.com/6000.0/Documentation/Manual/performance-garbage-collector.html">Understanding automatic memory management</a> for examples of how to use this to your advantage.</p>
<h3 id="use-the-incremental-garbage-collector-to-split-the-gc-workload">Use the Incremental Garbage Collector to split the GC workload</h3>
<p>Rather than creating a single, long interruption during your program&#39;s execution, incremental garbage collection uses multiple, much shorter interruptions that distribute the workload over many frames. If garbage collection is impacting performance, try enabling this option to see if it can reduce the problem of GC spikes. Use the Profile Analyzer to verify its benefit to your application.</p>
<p>Use the Incremental Garbage Collector to reduce GC spikes.</p>
<h1 id="-span-id-page-24-0-span-adaptive-performance"><span id="page-24-0"></span>Adaptive Performance</h1>
<p>With Unity and Samsung&#39;s <a href="https://developer.samsung.com/galaxy-gamedev/ap-userguide/v2.html">Adaptive Performance</a>, you can monitor the device&#39;s thermal and power state to ensure that you are ready to react appropriately. When users play for an extended period of time, you can reduce your level of detail (LOD) bias dynamically so that your game continues to run smoothly. Adaptive Performance allows developers to increase performance in a controlled way while maintaining graphics fidelity.</p>
<p>While you can use Adaptive Performance APIs to fine-tune your application, Adaptive Performance also offers several automatic modes. In these modes, Adaptive Performance determines the game settings along several key metrics:</p>
<ul>
<li>Desired frame rate based on previous frames</li>
<li>Device temperature level</li>
<li>Device proximity to thermal event</li>
<li>Device bound by CPU or GPU</li>
</ul>
<p>These four metrics dictate the state of the device, and Adaptive Performance tweaks the adjusted settings to reduce the bottleneck. This is done by providing an integer value, known as an Indexer, to describe the state of the device.</p>
<p>To learn more about Adaptive Performance, you can view the<a href="https://docs.unity3d.com/Packages/com.unity.adaptiveperformance@5.0/manual/samples-guide.html">samples</a> we&#39;ve provided in the Package Manager by selecting <strong>Package Manager &gt; Adaptive Performance &gt; Samples</strong>. Each sample interacts with a specific scaler, so you can see how the different scalers impact your game. We also recommend reviewing the <a href="https://docs.unity3d.com/Packages/com.unity.adaptiveperformance@5.0/manual/index.html">end-user documentation</a> to learn more about Adaptive Performance configurations and how you can interact directly with the API.</p>
<p><img src="_page_25_Picture_0.jpeg" alt=""></p>
<p>Note that Adaptive Performance only works for Samsung devices.</p>
<p><img src="_page_25_Picture_3.jpeg" alt=""></p>
<p>The Adaptive Performance package</p>
<p><img src="_page_25_Figure_5.jpeg" alt=""></p>
<h2 id="-span-id-page-26-0-span-assets"><span id="page-26-0"></span>Assets</h2>
<p>A well-optimized asset pipeline can speed up load times, reduce memory usage, and improve runtime performance. By working with an experienced technical artist, your team can define and enforce asset formats, specifications, and import settings to ensure an efficient and streamlined workflow.</p>
<p>Don&#39;t rely solely on default settings. Take advantage of the platform-specific override tab to optimize assets like textures, mesh geometry, and audio files. Incorrect settings can result in larger build sizes, longer build times, and poor memory usage.</p>
<p>Consider using <strong><a href="https://docs.unity3d.com/6000.0/Documentation/Manual/Presets.html">Presets</a></strong> to establish baseline settings tailored to your specific project needs. This proactive approach helps ensure that assets are optimized from the start, leading to better performance and a more consistent experience across all platforms.</p>
<p>For more guidance, refer to the <a href="https://docs.unity3d.com/Manual/HOWTO-ArtAssetBestPracticeGuide.html?utm_source=demand-gen&amp;utm_medium=pdf&amp;utm_campaign=asset-links-gmg-elevate-your-game&amp;utm_content=optimize-mobile-game-performance-ebook">best practices for art assets</a> or explore the <a href="https://learn.unity.com/course/3d-art-optimization-for-mobile-gaming-5474?utm_source=demand-gen&amp;utm_medium=pdf&amp;utm_campaign=clean-code&amp;utm_content=mobile-performance-optimization-ebook">3D Art Optimization</a> <a href="https://learn.unity.com/course/3d-art-optimization-for-mobile-gaming-5474?utm_source=demand-gen&amp;utm_medium=pdf&amp;utm_campaign=clean-code&amp;utm_content=mobile-performance-optimization-ebook">for Mobile Applications</a> course on Unity Learn. These resources provide valuable insights that can help you make informed decisions about asset optimization for Unity web builds, mobile, and XR applications.</p>
<p><span id="page-27-0"></span><img src="_page_27_Picture_0.jpeg" alt=""></p>
<h2 id="import-textures-correctly">Import textures correctly</h2>
<p>Import settings are crucial because textures often consume the most memory. Consider the following guidelines to optimize your textures:</p>
<ul>
<li><strong>Lower the Max Size</strong>: Use the minimum settings that produce visually acceptable results. This is non-destructive and can quickly reduce your texture memory.</li>
<li><strong>Use powers of two (POT)</strong>: Unity requires POT texture dimensions for mobile texture compression formats (PVRCT or ETC).</li>
</ul>
<table>
<thead>
<tr>
<th>C Inspector</th>
<th></th>
<th>3</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
<td>Open</td>
</tr>
<tr>
<td>Texture Type</td>
<td>Default</td>
<td></td>
</tr>
<tr>
<td>Texture Shape</td>
<td>2D</td>
<td></td>
</tr>
<tr>
<td>SRGB (Color Texture)</td>
<td>&gt;</td>
<td></td>
</tr>
<tr>
<td>Alpha Source</td>
<td>Input Texture Alpha</td>
<td>4</td>
</tr>
<tr>
<td>Alpha Is Transparency</td>
<td>0</td>
<td></td>
</tr>
<tr>
<td>P Advanced</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Non-Power of 2</td>
<td>ToNearest</td>
<td></td>
</tr>
<tr>
<td>Read/Write</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Virtual Texture Only</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Generate Mipmap</td>
<td>V</td>
<td></td>
</tr>
<tr>
<td>T Generation Settings</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Mipmap Filtering<br>Preserve Coverage</td>
<td>Box</td>
<td>&gt;</td>
</tr>
<tr>
<td>Replicate Border</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Fadeout to Gray</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Mipmap Limit</td>
<td>&gt;</td>
<td></td>
</tr>
<tr>
<td>Mipmap Limit Group</td>
<td>None (Use Global Mipmap Limit)</td>
<td>D</td>
</tr>
<tr>
<td>Stream Mipmap Levels</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Ignore PNG Gamma</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Swizzle</td>
<td>R<br>. G<br>B</td>
<td>- A</td>
</tr>
<tr>
<td>Wrap Mode</td>
<td>Repeat</td>
<td>-</td>
</tr>
<tr>
<td>Filter Mode</td>
<td>Billnear</td>
<td></td>
</tr>
<tr>
<td>Aniso Level</td>
<td>-- @</td>
<td></td>
</tr>
<tr>
<td>Default<br>0</td>
<td>C</td>
<td>0</td>
</tr>
<tr>
<td>J Override For IOS</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Max Size</td>
<td>2048</td>
<td>A</td>
</tr>
<tr>
<td>Resize Algorithm<br>Format</td>
<td>Mitchell<br>RGB(A) Compressed ASTC 8x8 block</td>
<td>D</td>
</tr>
<tr>
<td>Compressor Quality</td>
<td>Normal</td>
<td>A</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td>Revert Apply</td>
</tr>
<tr>
<td>Asset PostProcessors</td>
<td></td>
<td></td>
</tr>
<tr>
<td>WoodPlank_01_T_A</td>
<td>RGB<br>R<br>G</td>
<td>B<br>C<br>@ 95 :</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>WoodPlank_01_T_A<br>1024x1024 RGB Compressed DXT1 BC1 sRGB 0.7 MB</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td>4</td>
</tr>
<tr>
<td>AssetBundle<br>None</td>
<td></td>
<td>4<br>~ None</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>Proper texture import settings will help optimize your build size.</p>
<ul>
<li><strong>Atlas your textures</strong>: Atlasing is the process of grouping together several smaller textures into a single larger texture of uniform size. Placing multiple textures into a single texture can reduce draw calls and speed up rendering. Use the <a href="https://docs.unity3d.com/6000.0/Documentation/Manual/class-SpriteAtlas.html?">Unity Sprite Atlas</a> or the third-party <a href="https://www.codeandweb.com/texturepacker">TexturePacker</a> to atlas your textures.</li>
<li><strong>Toggle off the Read/Write Enabled option</strong>: When enabled, this option creates a copy in both CPU- and GPUaddressable memory, doubling the texture&#39;s memory footprint. In most cases, keep this disabled. If you are generating textures at runtime, enforce this via <strong>Texture2D.Apply</strong>, passing in <strong>makeNoLongerReadable</strong> set to <strong>true</strong>.</li>
<li><strong>Disable unnecessary mipmaps</strong>: While mipmaps can optimize performance by reducing the amount of detail that needs to be rendered at different distances from the camera, they aren&#39;t always needed. For textures that remain at a consistent size onscreen, such as 2D sprites and UI graphics you can leave them out (leave mipmaps enabled for 3D models with varying distance from the camera).</li>
</ul>
<p><span id="page-28-0"></span><img src="_page_28_Picture_0.jpeg" alt=""></p>
<h2 id="compress-textures">Compress textures</h2>
<p>Consider these two examples using the same model and texture. The settings on the left consume almost 26 times the memory as those on the right, without much improvement in visual quality.</p>
<p><img src="_page_28_Picture_4.jpeg" alt=""></p>
<p>Uncompressed textures require more memory.</p>
<p>Use Adaptive Scalable Texture Compression (ATSC) for mobile, XR and Web. The vast majority of games in development tend to target min-spec devices that support ATSC compression.</p>
<p>The only exceptions are:</p>
<ul>
<li>iOS games targeting A7 devices or lower (e.g., iPhone 5, 5S, etc.) use PVRTC</li>
<li>Android games targeting devices prior to 2016 use ETC2 (Ericsson Texture Compression)</li>
</ul>
<p>If compressed formats such as PVRTC and ETC aren&#39;t sufficiently high-quality, and if ASTC is not fully supported on your target platform, try using 16-bit textures instead of 32-bit textures.</p>
<p>See the manual for more information on <a href="https://docs.unity3d.com/6000.0/Documentation/Manual/class-TextureImporterOverride.html">recommended texture compression format by</a>  <a href="https://docs.unity3d.com/6000.0/Documentation/Manual/class-TextureImporterOverride.html">platform</a>.</p>
<p><span id="page-29-0"></span><img src="_page_29_Picture_1.jpeg" alt=""></p>
<p>Selecting ASTC for texture compression under the build settings</p>
<h3 id="adjust-mesh-import-settings">Adjust mesh import settings</h3>
<p>Just like textures, meshes can consume significant memory, so choose optimal import settings for them. Reduce the memory footprint of meshes with the following practices:</p>
<ul>
<li><strong>Compress the mesh:</strong> Aggressive compression can reduce disk space (memory at runtime, however, is unaffected). Note that mesh quantization can result in inaccuracies, so experiment with compression levels to see what works for your models.</li>
<li><strong>Disable Read/Write:</strong> Enabling this option duplicates the mesh in memory, which keeps one copy of the mesh in system memory and another in GPU memory. In most cases, you should disable it (in Unity 2019.2 and earlier, this option is checked by default).</li>
<li><strong>Disable rigs and blend shapes:</strong> If your mesh does not need skeletal or blendshape animation, disable these options wherever possible.</li>
<li><strong>Disable normals and tangents:</strong> If you are absolutely certain that the mesh material will not need normals or tangents, uncheck these options for extra savings.</li>
</ul>
<p><span id="page-30-0"></span><img src="_page_30_Picture_1.jpeg" alt=""></p>
<p>Check your mesh import settings.</p>
<h2 id="check-your-polygon-counts">Check your polygon counts</h2>
<p>Higher-resolution models mean more memory usage and potentially longer GPU times. Does your background geometry need half a million polygons? Consider cutting down models in your DCC package of choice. Delete unseen polygons from the camera&#39;s point of view, and use textures and normal maps for fine detail instead of high-density meshes.</p>
<h3 id="automate-your-import-settings-using-the-assetpostprocessor">Automate your import settings using the AssetPostprocessor</h3>
<p>The <a href="https://docs.unity3d.com/6000.0/Documentation/ScriptReference/AssetPostprocessor.html?">AssetPostprocessor</a> allows you to hook into the import pipeline and run scripts prior to or when importing assets. This prompts you to customize settings before and/or after importing models, textures, audio, and so on in a way similar to presets but through code. Learn more about the process in our GDC 2023 talk, &quot;<a href="https://youtu.be/o_QBMz0WZjI?list=PLX2vGYjWbI0TkxPwhWgsBhvj-EwxJDt5x&amp;t=816">Technical tips for every stage of game creation</a>.&quot;</p>
<h2 id="unity-datatools">Unity DataTools</h2>
<p><a href="https://github.com/Unity-Technologies/UnityDataTools">Unity DataTools</a> is a collection of open source tools provided by Unity that aims to enhance data management and serialization capabilities in Unity projects. It includes features for analyzing and optimizing project data, such as identifying unused assets, detecting asset dependencies, and reducing build size.</p>
<p><span id="page-31-0"></span><img src="_page_31_Picture_0.jpeg" alt=""></p>
<h2 id="use-the-addressable-asset-system">Use the Addressable Asset System</h2>
<p>The <a href="https://docs.unity3d.com/Packages/com.unity.addressables@2.3/manual/index.html">Addressable Asset System</a> provides a simplified way to manage your content. This unified system loads AssetBundles by &quot;address&quot; or alias, asynchronously from either a local path or a remote content delivery network (CDN).</p>
<p><img src="_page_31_Picture_4.jpeg" alt=""></p>
<p>If you split your non-code assets (models, textures, Prefabs, audio, and even entire scenes) into an <a href="https://docs.unity3d.com/6000.0/Documentation/Manual/AssetBundlesIntro.html?">AssetBundle,</a> you can separate them as downloadable content (DLC).</p>
<p>Then, use Addressables to create a smaller initial build for your mobile application. <a href="https://unity.com/products/cloud-content-delivery">Cloud</a>  <a href="https://unity.com/products/cloud-content-delivery">Content Delivery</a> lets you host and deliver your game content to players as they progress through the game.</p>
<table>
<thead>
<tr>
<th>Addressables Groups</th>
<th></th>
<th></th>
<th></th>
<th>X ■ ×</th>
</tr>
</thead>
<tbody>
<tr>
<td>Create · Profile: Default · Tools ·</td>
<td></td>
<td>Play Mode Script ▼ Build ▼</td>
<td>Q.</td>
<td>×</td>
</tr>
<tr>
<td>Group Name \ Addressable Name<br>Built In Data<br>Utility (Default)</td>
<td>Path</td>
<td></td>
<td>Labels</td>
<td></td>
</tr>
<tr>
<td>camera<br>checkpoint<br>volume_manager<br>Boats</td>
<td>6<br>Assets/Objects/misc/Main Camera.prefab<br>0<br>Assets/Objects/misc/checkpoint.prefab<br>0<br>Assets/Objects/misc/DefaultVolume.prefab</td>
<td></td>
<td>&gt;<br>A<br>D</td>
<td></td>
</tr>
<tr>
<td>boat_interceptor</td>
<td>20<br>Assets/Objects/boats/Interceptor/_Interceptor.prefab</td>
<td></td>
<td>&gt;</td>
<td></td>
</tr>
<tr>
<td>boat_renegade<br>boat effect wake</td>
<td>0<br>Assets/Objects/boats/renegade/_Renegade.prefab<br>0<br>Assets/Objects/misc/Wake.prefab</td>
<td></td>
<td>&gt;<br>&gt;</td>
<td></td>
</tr>
<tr>
<td>v UI</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>ui race<br>ui_loading_screen<br>ui_player_marker<br>ui_racestats_player<br>ui_race_touch<br>ui_player_map_marker</td>
<td>0<br>Assets/Objects/Ul/prefabs/InGame/Race_Canvas.prefab<br>6<br>Assets/Objects/Ul/prefabs/LoadingScreen.prefab<br>0<br>Assets/Objects/Ul/prefabs/InGame/PlayerMarker.prefab<br>8<br>Assets/Objects/Ul/prefabs/InGame/RaceStats_Player.prefab<br>20<br>Assets/Objects/Ul/prefabs/InGame/Race_Canvas_touch.prefab<br>6<br>Assets/Objects/Ul/prefabs/InGame/PlayerMapMarker.prefab</td>
<td></td>
<td>D<br>A<br>&gt;<br>V<br>&gt;<br>D</td>
<td></td>
</tr>
<tr>
<td>VolumeProfiles</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>vol_quality_low<br>vol_quality_medium<br>vol_quality_base<br>vol_quality_high</td>
<td>8<br>Assets/Data/Volumes/LowQuality.asset<br>8<br>Assets/Data/Volumes/MediumQuality.asset<br>જુન<br>Assets/Data/Volumes/BaseEffects.asset<br>8<br>Assets/Data/Volumes/HighQuality.asset</td>
<td></td>
<td>&gt;<br>D<br>&gt;<br>A</td>
</tr>
</tbody>
</table>
<p>Load assets by &quot;address&quot; using the Addressable Asset System.</p>
<p>Click <a href="https://unity.com/how-to/simplify-your-content-management-addressables?">here</a> to see how the Addressable Asset System can take the hassle out of asset management.</p>
<h2 id="-span-id-page-32-0-span-programming-and-code-architecture"><span id="page-32-0"></span>Programming and code architecture</h2>
<p>The Unity <a href="https://docs.unity3d.com/6000.0/Documentation/ScriptReference/LowLevel.PlayerLoop.html">PlayerLoop</a> contains functions for interacting with the core of the game engine. This structure includes a number of systems that handle initialization and per-frame updates. All of your scripts will rely on this PlayerLoop to create gameplay.</p>
<p>When profiling, you&#39;ll see your project&#39;s user code under the PlayerLoop (with Editor components under the EditorLoop).</p>
<p><img src="_page_32_Figure_3.jpeg" alt=""></p>
<p>The Profiler will show your custom scripts, settings, and graphics in the context of the entire engine&#39;s execution.</p>
<p>Optimize your scripts with the following tips and tricks.</p>
<p><span id="page-33-0"></span><img src="_page_33_Picture_0.jpeg" alt=""></p>
<h2 id="understand-the-unity-playerloop">Understand the Unity PlayerLoop</h2>
<p>Make sure you understand the <a href="https://docs.unity3d.com/6000.0/Documentation/Manual/ExecutionOrder.html?">execution order</a> of Unity&#39;s frame loop. Every Unity script runs several event functions in a predetermined order. You should understand the difference between <strong>Awake</strong>, <strong>Start</strong>, <strong>Update</strong>, and other functions that create the lifecycle of a script. You can utilize the Low-Level API to add custom logic to the player&#39;s update loop.</p>
<p><img src="_page_33_Figure_4.jpeg" alt=""></p>
<p>Get to know the PlayerLoop and the lifecycle of a script.</p>
<p><span id="page-34-0"></span><img src="_page_34_Picture_0.jpeg" alt=""></p>
<h2 id="minimize-code-that-runs-every-frame">Minimize code that runs every frame</h2>
<p>Consider whether code must run every frame. Move unnecessary logic out of <strong>Update</strong>, <strong>LateUpdate</strong>, and <strong>FixedUpdate</strong>. These event functions are convenient places to put code that must update every frame, while extracting any logic that does not need to update with that frequency. Whenever possible, only execute logic when things change.</p>
<p>If you <em>do</em> need to use <strong>Update</strong>, consider running the code every <em>n</em> frames. This is one way to apply time slicing, a common technique of distributing a heavy workload across multiple frames. In this example, we run the <strong>ExampleExpensiveFunction</strong> once every three frames:</p>
<pre><code><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> interval = <span class="hljs-number">3</span>;
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Update</span><span class="hljs-params">()</span>
</span>{
 <span class="hljs-keyword">if</span> (Time.frameCount % interval == <span class="hljs-number">0</span>)
 {
 ExampleExpensiveFunction();
 }
}
</code></pre><p>Better yet, if <strong>ExampleExpensiveFunction</strong> performs some operation on a set of data, consider using time slicing to operate on a different subset of that data every frame. By doing 1/n of the work every frame rather than all of the work every n frames, you end up with performance that is more stable and predictable overall, rather than seeing periodic CPU spikes.</p>
<h3 id="avoid-heavy-logic-in-start-awake">Avoid heavy logic in Start/Awake</h3>
<p>When your first scene loads, these functions get called for each object:</p>
<ul>
<li><strong>Awake</strong></li>
<li><strong>OnEnable/OnDisable</strong></li>
<li><strong>Start</strong></li>
</ul>
<p>Avoid expensive logic in these functions until your application renders its first frame. Otherwise, you might encounter longer loading times than necessary.</p>
<p>Refer to the <a href="https://docs.unity3d.com/6000.0/Documentation/Manual/ExecutionOrder.html?">order of execution for event functions</a> for more details.</p>
<p><span id="page-35-0"></span><img src="_page_35_Picture_0.jpeg" alt=""></p>
<h2 id="avoid-empty-unity-events">Avoid empty Unity events</h2>
<p>Even empty MonoBehaviours require resources, so you should remove blank <strong>Update</strong> or <strong>LateUpdate</strong> methods.</p>
<p>Use preprocessor directives if you are employing these methods for testing:</p>
<pre><code><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> UNITY_EDITOR</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Update</span><span class="hljs-params">()</span>
</span>{
}
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>
</code></pre><p>Here, you can freely use the <strong>Update</strong> in-Editor for testing without unnecessary overhead slipping into your build.</p>
<h2 id="remove-debug-log-statements">Remove Debug Log statements</h2>
<p>Log statements (especially in <strong>Update</strong>, <strong>LateUpdate</strong>, or <strong>FixedUpdate</strong>) can bog down performance. Disable your <strong>Log</strong> statements before making a build.</p>
<p>To do this more easily, consider making a <a href="https://docs.microsoft.com/en-us/dotnet/api/system.diagnostics.conditionalattribute?view=net-5.0">Conditional attribute</a> along with a preprocessing directive. For example, create a custom class like this:</p>
<p><img src="_page_35_Figure_10.jpeg" alt=""></p>
<table>
<thead>
<tr>
<th>Script Compilation</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>Scripting Define Symbols</td>
<td></td>
</tr>
<tr>
<td>URP</td>
<td></td>
</tr>
<tr>
<td>USE_CUSTOM_METADATA</td>
<td></td>
</tr>
<tr>
<td>ENABLE_LOG</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>Copy Defines Revert Apply</td>
</tr>
</tbody>
</table>
<p>Adding a custom preprocessor directive lets you partition your scripts.</p>
<p><span id="page-36-0"></span><img src="_page_36_Picture_0.jpeg" alt=""></p>
<p>Generate your log message with your custom class. If you disable the <strong>ENABLE_LOG</strong>  preprocessor in the <strong>Player Settings</strong>, all of your <strong>Log</strong> statements disappear in one fell swoop.</p>
<p>The same thing applies for other use cases of the Debug Class, such as Debug.DrawLine and Debug.DrawRay. These are also only intended for use during development and can significantly impact performance.</p>
<h2 id="use-hash-values-instead-of-string-parameters">Use hash values instead of string parameters</h2>
<p>Unity does not use string names to address animator, material, and shader properties internally. For speed, all property names are hashed into property IDs, and these IDs are actually used to address the properties.</p>
<p>When using a Set or Get method on an animator, material, or shader, harness the integervalued method instead of the string-valued methods. The string methods simply perform string hashing and then forward the hashed ID to the integer-valued methods.</p>
<p>Use <a href="https://docs.unity3d.com/6000.0/Documentation/ScriptReference/Animator.StringToHash.html?">Animator.StringToHash</a> for Animator property names and <a href="https://docs.unity3d.com/6000.0/Documentation/ScriptReference/Shader.PropertyToID.html?">Shader.PropertyToID</a> for material and shader property names. Get these hashes during initialization and cache them in variables for when they&#39;re needed to pass to a Get or Set method.</p>
<h2 id="choose-the-right-data-structure">Choose the right data structure</h2>
<p>Your choice of data structure impacts efficiency as you iterate thousands of times per frame. Not sure whether to use a List, Array, or Dictionary for your collection? Follow the <a href="https://msdn.microsoft.com/en-us/library/7y3x785f">MSDN guide</a>  <a href="https://msdn.microsoft.com/en-us/library/7y3x785f">to data structures</a> in C# as a general guide for choosing the correct structure.</p>
<h3 id="avoid-adding-components-at-runtime">Avoid adding components at runtime</h3>
<p>Invoking <strong>AddComponent</strong> at runtime comes with some cost. Unity must check for duplicate or other required components whenever adding components at runtime.</p>
<p><a href="https://docs.unity3d.com/6000.0/Documentation/Manual/Prefabs.html">Instantiating a prefab</a> with the desired components already set up is generally more performant.</p>
<h2 id="cache-gameobjects-and-components">Cache GameObjects and components</h2>
<p>It&#39;s best to cache references in either Awake or Start in order to avoid calling them in the Update method..</p>
<p>Here&#39;s an example that demonstrates the inefficient use of a repeated <strong>GetComponent</strong> call:</p>
<pre><code>void Update()
{
 Renderer myRenderer = GetComponent&lt;Renderer&gt;()<span class="hljs-comment">;</span>
 ExampleFunction(myRenderer)<span class="hljs-comment">;</span>
}
</code></pre><p><span id="page-37-0"></span><img src="_page_37_Picture_0.jpeg" alt=""></p>
<p>It&#39;s more efficient to invoke <strong>GetComponent</strong> only once, as the result of the function is cached. The cached result can be reused in <strong>Update</strong> without any further calls to <strong>GetComponent</strong>.</p>
<pre><code><span class="hljs-keyword">private</span> Renderer myRenderer;
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Start</span><span class="hljs-params">()</span>
</span>{
 myRenderer = GetComponent&lt;Renderer&gt;();
}
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Update</span><span class="hljs-params">()</span>
</span>{
 ExampleFunction(myRenderer);
}
</code></pre><p>In Unity versions prior to Unity 2020.2 <strong>GameObject.Find</strong>, <strong>GameObject.GetComponent</strong>, and <strong>Camera.main</strong> used to be very expensive, however this is no longer the case. That said, it&#39;s best to avoid calling them in <strong>Update</strong> methods and follow the practice above by caching the results.</p>
<h2 id="use-object-pools">Use object pools</h2>
<p><strong>Instantiate</strong> and <strong>Destroy</strong> can generate garbage and garbage collection (GC) spikes, which generally results in a slow process. Apply object pooling techniques when you need to instantiate a large number of objects.</p>
<p><img src="_page_37_Picture_7.jpeg" alt=""></p>
<p>In this example, the ObjectPool creates 20 PlayerLaser instances for reuse.</p>
<p>A best practice for object pooling is to create the reusable instances when a CPU spike is less noticeable (e.g., during a menu screen). Then track this &quot;pool&quot; of objects with a collection. During gameplay, enable the next available instance when needed, disable objects instead of destroying them, and return them to the pool.</p>
<p><span id="page-38-0"></span><img src="_page_38_Picture_0.jpeg" alt=""></p>
<p><img src="_page_38_Figure_1.jpeg" alt=""></p>
<p>An example of a pool of projectile objects that&#39;s inactive and ready to shoot.</p>
<p>This reduces the number of managed allocations in your project and can prevent garbage collection problems. Unity includes a built-in object pooling feature via the <a href="https://docs.unity3d.com/6000.0/Documentation/ScriptReference/Pool.ObjectPool_1.html">UnityEngine.Pool</a>  namespace. Available in Unity 2021 LTS and later, this namespace facilitates the management of object pools, automating aspects like object lifecycle and pool size control.</p>
<p>Learn how to create a simple object pooling system in Unity <a href="https://learn.unity.com/tutorial/introduction-to-object-pooling">here</a>. You can also see the object pooling pattern, and many others, implemented in a Unity scene <a href="https://assetstore.unity.com/packages/essentials/tutorial-projects/level-up-your-code-with-design-patterns-and-solid-289616">in this sample project</a>  <a href="https://assetstore.unity.com/packages/essentials/tutorial-projects/level-up-your-code-with-design-patterns-and-solid-289616">available on the Unity Asset Store.</a></p>
<h2 id="use-scriptableobjects">Use ScriptableObjects</h2>
<p>Store static values or settings in a <strong>ScriptableObject</strong> instead of a MonoBehaviour. The ScriptableObject is an asset that lives inside of the project that you only need to set up once.</p>
<p>MonoBehaviours carry extra overhead since they require a GameObject – and by default a Transform – to act as a host. That means you need to create a lot of unused data before storing a single value. The ScriptableObject slims down this memory footprint by dropping the GameObject and Transform. It also stores the data at the project level, which is helpful if you need to access the same data from multiple scenes.</p>
<p><img src="_page_39_Picture_0.jpeg" alt=""></p>
<p>A common use case is having many GameObjects that rely on the same duplicate data that does not need to change at runtime. Rather than having this duplicate local data on each GameObject, you can funnel it into a ScriptableObject. Then, each of the objects stores a reference to the shared data asset, rather than copying the data itself. This can provide significant performance improvements in projects with thousands of objects.</p>
<p>Create fields in the ScriptableObject to store your values or settings, then reference the ScriptableObject in your MonoBehaviours.</p>
<p><img src="_page_39_Figure_4.jpeg" alt=""></p>
<p>In this example, a ScriptableObject called Inventory holds settings for various GameObjects.</p>
<p>Using those fields from the ScriptableObject can prevent unnecessary duplication of data every time you instantiate an object with that MonoBehaviour.</p>
<p>In software design, this is an optimization known as the flyweight pattern. Restructuring your code in this way using ScriptableObjects avoids copying a lot of values and reduces your memory footprint. Learn more about the flyweight pattern and many others, as well as design principles, in the e-book <em><a href="https://unity.com/resources/design-patterns-solid-ebook?isGated=alse">Level up your code with design patterns and SOLID</a></em>.</p>
<p>Watch this <a href="https://youtu.be/WLDgtRNK2VE">Introduction to ScriptableObjects</a> devlog to see how ScriptableObjects can benefit your project. Reference Unity documentation <a href="https://docs.unity3d.com/Manual/class-ScriptableObject.html">here</a> as well as the technical guide <em><a href="https://resources.unity.com/games/create-modular-game-architecture-with-scriptable-objects-ebook?ungated=true">Create</a>  <a href="https://resources.unity.com/games/create-modular-game-architecture-with-scriptable-objects-ebook?ungated=true">modular game architecture in Unity with ScriptableObjects</a></em>.</p>
<h1 id="-span-id-page-40-0-span-project-configuration"><span id="page-40-0"></span>Project configuration</h1>
<p>There are a few Project Settings that can affect your mobile performance.</p>
<h2 id="reduce-or-disable-accelerometer-frequency">Reduce or disable Accelerometer Frequency</h2>
<p>Unity pools your mobile&#39;s accelerometer several times per second. Disable this if it&#39;s not being used in your application, or reduce its frequency for better overall performance.</p>
<table>
<thead>
<tr>
<th>9 Project Settings</th>
<th></th>
<th></th>
<th>0<br>×</th>
</tr>
</thead>
<tbody>
<tr>
<td>Project Settings</td>
<td></td>
<td>ರ</td>
<td></td>
</tr>
<tr>
<td>Adaptive Performance<br>Audio</td>
<td>Player</td>
<td></td>
<td>0 2</td>
</tr>
<tr>
<td>Burst AOT Settings<br>Editor<br>Graphics<br>Input Manager<br>Input System Package<br>Settings<br>Memory Settings<br>Package Manager<br>Physics<br>Settings<br>Physics 2D<br>Player<br>Preset Manager<br>Quality<br>Scene Template<br>Script Execution Order<br>Services<br>ShaderGraph<br>Tags and Layers<br>TextMesh Pro<br>Settings<br>Time<br>Timeline<br>UI Toolkit<br>Version Control<br>VEX<br>Visual Scripting<br>XR Plugin Management</td>
<td>Automatically Sign<br>iOS Provisioning Profile<br>Profile ID:<br>Profile Type:<br>Configuration<br>Scripting Backend<br>Api Compatibility Level®<br>Editor Assemblies Compatibility Level®<br>IL2CPP Code Generation<br>C++ Compiler Configuration<br>IL2CPP Stacktrace Information<br>Use incremental GC<br>Allow downloads over HTTP<em><br>Camera Usage Description®<br>Microphone Usage Description®<br>Location Usage Description</em><br>Use on-demand resources®<br>Accelerometer Frequency®<br>Mute Other Audio Sources®<br>Prepare iOS for Recording<br>Audio input from Bluetooth microphones<br>Force IOS Speakers when Recording<br>Requires Persistent WiFi®<br>&gt; Supported URL schemes*<br>Target Device<br>Target SDK</td>
<td>E<br>Automatic<br>IL2CPP<br>.NET Standard 2.1<br>Default (.NET Framework)<br>Fastor runtimo<br>Release<br>Method Name<br>&gt;<br>Not allowed<br>Disabled<br>Disabled<br>15 Hz<br>30 Hz<br>ter Audio Sources and Prepare IOS for Recording are both off.<br>60 Hz<br>100 Hz<br>IPhone + IPad<br>Device SDK</td>
<td>Browse<br>V<br>V<br>0</td>
</tr>
</tbody>
</table>
<p>Ensure your Accelerometer Frequency is disabled if you are not making use of it in your mobile game.</p>
<p><span id="page-41-0"></span><img src="_page_41_Picture_0.jpeg" alt=""></p>
<h2 id="disable-unnecessary-player-or-quality-settings">Disable unnecessary Player or Quality settings</h2>
<p>In the <strong>Player</strong> settings, disable <strong>Auto Graphics API</strong> for unsupported platforms to prevent generating excessive shader variants. Disable <strong>Target Architectures</strong> for older CPUs if your application is not supporting them.</p>
<p>In the <strong>Quality</strong> settings, disable needless Quality levels.</p>
<h2 id="disable-unnecessary-physics">Disable unnecessary physics</h2>
<p>If your game is not using physics, uncheck <strong>Auto Simulation</strong> and <strong>Auto Sync Transforms</strong>. These will just slow down your application with no discernible benefit.</p>
<h2 id="choose-the-right-frame-rate">Choose the right frame rate</h2>
<p>Mobile projects must balance frame rates against battery life and thermal throttling. Instead of pushing the limits of your device at 60 fps, consider running at 30 fps as a compromise. Unity defaults to 30 fps for mobile.</p>
<p>When targeting XR platforms, the frame rate considerations are even more critical. A frame rate of 72 fps, 90 fps, or even 120 fps, is often necessary to maintain immersion and prevent motion sickness. These higher frame rates help ensure a smooth and responsive experience, which is crucial for comfort in VR environments. However, these come with their own challenges in terms of power consumption and thermal management, particularly in standalone VR headsets.</p>
<p>Choosing the right frame rate is about understanding the specific demands and constraints of your target platform, whether it&#39;s a mobile device, a standalone VR headset, or an AR device. By carefully selecting an appropriate frame rate, you can optimize both performance and user experience across different platforms.</p>
<p>You can also adjust the frame rate dynamically during runtime with <strong>Application. targetFrameRate</strong>. For example, you could drop below 30 fps for slow or relatively static scenes and reserve higher fps settings for gameplay.</p>
<h2 id="avoid-large-hierarchies">Avoid large hierarchies</h2>
<p>Split your hierarchies. If your GameObjects do not need to be nested in a hierarchy, simplify the parenting. Smaller hierarchies benefit from multithreading to refresh the Transforms in your scene. Complex hierarchies incur unnecessary Transform computations and more cost to garbage collection.</p>
<p><span id="page-42-0"></span><img src="_page_42_Picture_0.jpeg" alt=""></p>
<h2 id="transform-once-not-twice">Transform once, not twice</h2>
<p>Additionally, when moving Transforms, use <a href="https://docs.unity3d.com/6000.0/Documentation/ScriptReference/Transform.SetPositionAndRotation.html?">Transform.SetPositionAndRotation</a> to update both position and rotation at once. This avoids the overhead of modifying a transform twice.</p>
<p>If you need to <a href="https://docs.unity3d.com/6000.0/Documentation/ScriptReference/Object.Instantiate.html">instantiate</a> a GameObject at runtime, a simple optimization is to parent and reposition during instantiation:</p>
<p><strong>GameObject.Instantiate(prefab, parent); GameObject.Instantiate(prefab, parent, position, rotation);</strong></p>
<p>For more on Object.Instantiate, please see the <a href="https://docs.unity3d.com/6000.0/Documentation/ScriptReference/Object.Instantiate.html">Scripting API.</a></p>
<h4 id="-vsync-in-xr-web-and-mobile-development-"><strong>Vsync in XR, web, and mobile development</strong></h4>
<p>When developing for XR, web, and mobile platforms, assume that Vsync (Vertical Synchronization) is enabled, even if you disable it in the Unity Editor (Project Settings &gt; Quality). Vsync is often enforced at the hardware level on these platforms to prevent screen tearing and ensure smooth visual output. If the GPU cannot render a frame quickly enough to match the display&#39;s refresh rate, the current frame will be held and displayed again, effectively reducing your fps. Let&#39;s look at how this works per platform.</p>
<ul>
<li>Mobile Platforms: Mobile devices typically enforce Vsync to match the display&#39;s refresh rate, often at 60Hz or higher on newer devices. If your application&#39;s frame rate drops below this target, the device will hold the previous frame, causing noticeable stuttering or input lag. It&#39;s crucial to optimize rendering performance to maintain a steady frame rate, ensuring smooth operation across a variety of mobile devices with different performance capabilities.</li>
<li>Web Platforms: Web browsers also tend to enforce Vsync, particularly in Unity Web, to ensure synchronization with the display&#39;s refresh rate. Given the additional overhead of running within a browser, optimizing your application to maintain a consistent frame rate is essential to avoid visible performance drops. Test across different browsers and devices as web platforms can vary in their capabilities.</li>
<li>XR Platforms: In XR environments, maintaining a high and stable frame rate is even more critical due to the immersive nature of these experiences. Most XR devices enforce Vsync at 90Hz or higher, and any drop in frame rate can lead to discomfort or motion sickness for users. Optimizing every aspect of your application, from rendering to physics calculations, is essential to ensure the GPU can consistently meet these high demands.</li>
</ul>
<p>By understanding how Vsync is managed across XR, web, and mobile platforms, and by optimizing your application to maintain a consistent frame rate, you can deliver smoother, more responsive experiences that meet the expectations of users on these diverse platforms.</p>
<p><span id="page-43-0"></span><img src="_page_43_Picture_0.jpeg" alt=""></p>
<h4 id="-vsync-count-"><strong>Vsync Count</strong></h4>
<p>The <strong>Vsync Count</strong> setting in Unity&#39;s Quality settings determines how the rendering of frames is synchronized with the display&#39;s refresh rate. When set to <strong>Every V Blank</strong> (equivalent to a Vsync Count of 1), Unity synchronizes the rendering of frames with each vertical blank, effectively capping the frame rate to match the display&#39;s refresh rate (e.g., 60Hz = 60 FPS). This helps prevent screen tearing and ensures smooth visual output.</p>
<p>Alternatively, setting it to <strong>Every Second V Blank</strong> (Vsync Count of 2) halves the frame rate, which might be useful in situations where your application struggles to maintain full refresh rate performance. Disabling Vsync (Don&#39;t Sync) allows for maximum FPS but can result in screen tearing. On some platforms, Vsync may still be enforced at the hardware level regardless of this setting.</p>
<p><img src="_page_43_Figure_5.jpeg" alt=""></p>
<p>VSync count within the Quality settings</p>
<h2 id="-span-id-page-44-0-span-graphics-and-gpu-optimization"><span id="page-44-0"></span>Graphics and GPU optimization</h2>
<p>With each frame, Unity determines the objects that must be rendered and then creates draw calls. A draw call is a call to the graphics API to draw objects (e.g., a triangle), whereas a batch is a group of draw calls to be executed together.</p>
<p>As your projects become more complex, you&#39;ll need a pipeline that optimizes the workload on your GPU. The <strong><a href="https://docs.unity3d.com/Packages/com.unity.render-pipelines.universal@17.0/manual/index.html">Universal Render Pipeline (URP)</a></strong> supports three options for rendering: Forward, Forward+, and Deferred.</p>
<p>Forward rendering evaluates all lighting in a single pass and is generally recommended as default for mobile games. Forward+, introduced with Unity 2022 LTS, improves upon standard Forward rendering by culling lights spatially rather than per object. This significantly increases the overall number of lights that can be utilized in rendering a frame. Deferred mode is a good choice for specific cases, such as for games with lots of dynamic light sources. The same physically based lighting and materials from consoles and PCs can also scale to your phone or tablet.</p>
<p><img src="_page_45_Picture_0.jpeg" alt=""></p>
<p>The following table compares the three rendering options in URP.</p>
<table>
<thead>
<tr>
<th>Feature</th>
<th>Forward</th>
<th>Forward+</th>
<th>Deferred</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>Maximum<br>number of real<br>time lights per<br>object</td>
<td>9</td>
<td>Unlimited; the<br>per-Camera limit<br>applies</td>
<td>Unlimited</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>Two options:</td>
<td></td>
</tr>
<tr>
<td>Per pixel normal<br>encoding</td>
<td>No encoding<br>(accurate<br>normal<br>values)</td>
<td></td>
<td>Quantization of normals in G-buffer (loss of<br>accuracy, better performance)</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td>No encoding<br>(accurate normal<br>values)</td>
<td>Octahedron encoding (accurate normals,<br>might have significant performance impact<br>on mobile GPUs)</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>For more information, see Encoding of<br>normals in G-buffer.</td>
<td></td>
</tr>
<tr>
<td>MSAA</td>
<td>Yes</td>
<td>Yes</td>
<td>No</td>
<td></td>
</tr>
<tr>
<td>Vertex lighting</td>
<td>Yes</td>
<td>No</td>
<td>No</td>
<td></td>
</tr>
<tr>
<td>Camera<br>stacking</td>
<td>Yes</td>
<td>Yes</td>
<td>Supported with a limitation: Unity renders<br>only the base Camera using the Deferred<br>path; Unity renders all overlay Cameras<br>using the Forward Rendering path</td>
</tr>
</tbody>
</table>
<p>Learn more about using URP in Unity projects in the e-book <em><a href="https://unity.com/resources/introduction-to-urp-advanced-creators-unity-6">Introduction to the Universal</a>  <a href="https://unity.com/resources/introduction-to-urp-advanced-creators-unity-6">Render Pipeline for advanced Unity creators</a></em>.</p>
<h1 id="-span-id-page-46-0-span-gpu-optimization"><span id="page-46-0"></span>GPU optimization</h1>
<p>To optimize your graphics rendering, it&#39;s essential to understand the limitations of your target hardware – whether it&#39;s VR, mobile, or web – and how to effectively profile the GPU. Profiling allows you to check and verify that your optimizations are having the desired impact.</p>
<ul>
<li><strong>VR</strong>: VR hardware demands high frame rates (typically 90 FPS or higher) and low latency to maintain a smooth and immersive experience. The GPU needs to render complex scenes twice (once for each eye), which requires careful optimization of both performance and visual fidelity.</li>
<li><strong>Mobile</strong>: Mobile devices have limited processing power and memory compared to desktops and consoles. Optimizations should focus on minimizing draw calls, reducing texture sizes, and using simplified shaders to ensure smooth performance without draining the battery or overheating the device.</li>
<li><strong>Web</strong>: Web platforms, particularly when using Unity Web, must balance performance with the constraints of running in a browser environment. Optimization should prioritize reducing build size, minimizing load times, and ensuring compatibility across different browsers and hardware configurations.</li>
</ul>
<p>Use these best practices for reducing the rendering workload on the GPU.</p>
<h2 id="benchmark-the-gpu">Benchmark the GPU</h2>
<p>When profiling, it&#39;s useful to start with a benchmark. A benchmark tells you what profiling results you should expect from specific GPUs.</p>
<p><span id="page-47-0"></span><img src="_page_47_Picture_0.jpeg" alt=""></p>
<p>See <a href="https://gfxbench.com/result.jsp">GFXBench</a> for a great list of different industry-standard benchmarks for GPUs and graphics cards. The website provides a good overview of the current GPUs available and how they stack up against each other.</p>
<h2 id="watch-the-rendering-statistics">Watch the rendering statistics</h2>
<p>Click the <strong>Stats</strong> button in the top right of the Game view. This window shows you real-time rendering information about your application during Play mode. Use this data to help optimize performance:</p>
<ul>
<li><strong>fps</strong>: Frames per second</li>
<li><strong>CPU Main:</strong> Total time to process one frame (and update the Editor for all windows)</li>
<li><strong>CPU Render thread:</strong> Total time to render one frame of the Game view</li>
<li><strong>Batches:</strong> Groups of draw calls to be drawn together</li>
<li><strong>Tris (triangles) and Verts (vertices):</strong> Mesh geometry complexity</li>
<li><strong>SetPass calls:</strong> The number of times Unity must switch shader passes to render the GameObjects onscreen; each pass can introduce extra CPU overhead.</li>
</ul>
<p>Note: In-Editor fps does not necessarily translate to build performance. We recommend that you profile your build for the most accurate results. Frame time in milliseconds is a <a href="http://www.mvps.org/directx/articles/fps_versus_frame_time.htm">more accurate metric than frames per second</a> when benchmarking.</p>
<p><img src="_page_47_Picture_12.jpeg" alt=""></p>
<p>Stats window displaying real-time rendering info</p>
<p><span id="page-48-0"></span><img src="_page_48_Picture_0.jpeg" alt=""></p>
<h2 id="reduce-draw-calls">Reduce Draw Calls</h2>
<p>When rendering a GameObject, it issues a draw call to the graphics API (e.g., OpenGL, Vulkan, or Direct3D). Each draw call is resource-intensive, as the CPU must prepare and send the necessary data to the GPU, which then processes the command to render the object. Frequent state changes between draw calls, such as switching materials, can further increase CPU overhead.</p>
<p>While PC and console hardware can handle a large number of draw calls, the overhead remains significant enough to justify optimization. On mobile devices, VR headsets, and web browsers, draw call optimization is crucial for maintaining performance. By reducing the number of draw calls, you can ensure smoother and more efficient rendering, especially on resource-constrained platforms.</p>
<p>To optimize performance, especially on web, VR, and mobile platforms, reducing draw calls is essential. Here are key strategies to achieve this:</p>
<ul>
<li><ol>
<li><strong>Use a texture atlas</strong>: Combine multiple textures into a single texture atlas to minimize the number of texture bindings and draw calls. This is particularly important in web and mobile environments where reducing state changes can improve rendering efficiency.</li>
</ol>
</li>
<li><ol>
<li><strong>Optimize materials</strong>: Limit the number of materials and shaders used in your project. Shared materials are easier to batch together and reduce the draw call overhead.</li>
</ol>
</li>
<li><ol>
<li><strong>Implement LOD (Level of Detail)</strong>: Use LOD techniques to decrease the complexity of distant objects, reducing the number of draw calls for objects that are far from the camera. This approach is vital for VR, where maintaining high frame rates is critical to prevent motion sickness, and for mobile platforms, where processing power is limited.</li>
</ol>
</li>
<li><ol>
<li><strong>Apply culling techniques</strong>: Use frustum culling and occlusion culling to ensure that only visible objects are rendered. By not drawing objects that are outside the camera&#39;s view or obscured by other geometry, you can reduce the number of draw calls, improving performance across all platforms, especially in resource-constrained web and mobile environments.</li>
</ol>
</li>
</ul>
<h4 id="-use-draw-call-batching-"><strong>Use draw call batching</strong></h4>
<p><a href="https://docs.unity3d.com/6000.0/Documentation/Manual/DrawCallBatching.html?">Draw call batching</a> is an optimization method that combines meshes so that Unity can render them in fewer draw calls.</p>
<p>Draw call batching minimizes these state changes and reduces the CPU cost of rendering objects. Unity can combine multiple objects into fewer batches using several techniques:</p>
<p>— <strong>SRP Batching:</strong> If you are using HDRP or URP, enable the <a href="https://blog.unity.com/engine-platform/srp-batcher-speed-up-your-rendering">SRP Batcher</a> in your Pipeline Asset settings under <strong>Advanced</strong>. When using compatible shaders, the SRP Batcher reduces the GPU setup between draw calls and makes material data persistent in GPU Memory. This can speed up your CPU rendering times significantly. Use fewer <a href="https://docs.unity3d.com/6000.0/Documentation/Manual/SL-MultipleProgramVariants.html?">Shader</a>  <a href="https://docs.unity3d.com/6000.0/Documentation/Manual/SL-MultipleProgramVariants.html?">Variants</a> with a minimal amount of Keywords to improve SRP batching. Consult <a href="https://docs.unity3d.com/6000.0/Documentation/Manual/SRPBatcher.html">this SRP</a>  <a href="https://docs.unity3d.com/6000.0/Documentation/Manual/SRPBatcher.html">documentation</a> to see how your project can take advantage of this rendering workflow.</p>
<table>
<thead>
<tr>
<th>C Inspector</th>
<th></th>
<th>a</th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>Pipeline Asset_High (Universal Render Pipeline Asset)</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Addressable</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>General</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Quality<br>A</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Lighting<br>A</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Shadows</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Post-processing</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Advanced</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>SRP Batcher</td>
<td>V</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Dynamic Batching</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Mixed Lighting</td>
<td>&gt;</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Debug Level</td>
<td>Disabled</td>
<td>D</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Shader Variant Log Level</td>
<td>Disabled</td>
<td>D</td>
<td></td>
</tr>
</tbody>
</table>
<p>SRP Batcher helps you batch draw calls.</p>
<ul>
<li><strong>GPU instancing:</strong> If you have a large number of identical objects (e.g., buildings, trees, grass, and so on with the same mesh and material), use <a href="https://docs.unity3d.com/6000.0/Documentation/Manual/GPUInstancing.html">GPU instancing.</a> This technique batches them using graphics hardware. To enable GPU Instancing, select your material in the Project window, and in the Inspector, check <strong>Enable Instancing</strong>.</li>
<li><strong>Static batching:</strong> For non-moving geometry, Unity can reduce draw calls for any meshes sharing the same material. It is more efficient than dynamic batching, but it uses more memory.</li>
</ul>
<p>Mark all meshes that never move as <strong>Batching Static</strong> in the Inspector. Unity combines all static meshes into one large mesh at build time. The <a href="https://docs.unity3d.com/6000.0/Documentation/ScriptReference/StaticBatchingUtility.html?">StaticBatchingUtility</a> also allows you to create these static batches yourself at runtime (for example, after generating a procedural level of non-moving parts).</p>
<p>— <strong>Dynamic Batching:</strong> For small meshes, Unity can group and transform vertices on the CPU, then draw them all in one go. Note: Do <em>not</em> use this unless you have enough low-poly meshes (no more than 300 vertices each and 900 total vertex attributes). Otherwise, enabling it will waste CPU time looking for small meshes to batch.</p>
<p>You can maximize the effects of batching with a few simple rules:</p>
<ul>
<li>Use as few textures in a scene as possible. Fewer textures require fewer unique materials, making them easier to batch. Additionally, use texture atlases wherever possible.</li>
<li>Always bake lightmaps at the largest atlas size possible. Fewer lightmaps require fewer material state changes, but keep an eye on the memory footprint.</li>
<li>Be careful not to instance materials unintentionally. Accessing <a href="https://docs.unity3d.com/6000.0/Documentation/ScriptReference/Renderer-material.html?">Renderer.material</a> in scripts duplicates the material and returns a reference to the new copy. This breaks any existing batch that already includes the material. If you wish to access the batched object&#39;s material, use <a href="https://docs.unity3d.com/6000.0/Documentation/ScriptReference/Renderer-sharedMaterial.html?">Renderer.sharedMaterial</a> instead.</li>
</ul>
<p><span id="page-50-0"></span><img src="_page_50_Picture_0.jpeg" alt=""></p>
<p>— Keep an eye on the number of static and dynamic batch counts versus the total draw call count by using the Profiler or the rendering stats during optimizations.</p>
<p>Please refer to the <a href="https://docs.unity3d.com/6000.0/Documentation/Manual/DrawCallBatching.html">Draw Call Batching</a> documentation for more information.</p>
<h4 id="-gpu-resident-drawer-"><strong>GPU Resident Drawer</strong></h4>
<p>The GPU Resident Drawer (available for both <a href="https://docs.unity3d.com/Packages/com.unity.render-pipelines.universal@17.0/manual/gpu-resident-drawer.html">URP</a> and <a href="https://docs.unity3d.com/Packages/com.unity.render-pipelines.high-definition@17.0/manual/gpu-resident-drawer.html">HDRP</a>) is a GPU-driven rendering system that optimizes CPU time to boost performance. It supports cross-platform rendering, including high-end mobile platforms using Vulkan and Metal, and is designed to work out-ofthe-box with existing projects.</p>
<p>The <a href="https://docs.unity3d.com/Packages/com.unity.render-pipelines.universal@17.0/manual/gpu-resident-drawer.html">GPU Resident Drawer</a> uses the <a href="https://docs.unity3d.com/Manual/batch-renderer-group.html">BatchRendererGroup</a> API to draw GameObjects with GPU instancing, which reduces the number of draw calls and frees CPU processing time. The GPU Resident Drawer works only with the following:</p>
<ul>
<li>The <a href="https://docs.unity3d.com/Packages/com.unity.render-pipelines.universal@17.0/manual/rendering/forward-plus-rendering-path.html">Forward+</a> rendering path</li>
<li><a href="https://docs.unity3d.com/6000.0/Documentation/Manual/GraphicsAPIs.html">Graphics APIs</a> and platforms that support compute shaders, except OpenGL ES</li>
<li>GameObjects that have a <a href="https://docs.unity3d.com/6000.0/Documentation/Manual/class-MeshRenderer.html">Mesh Renderer component</a></li>
</ul>
<p><img src="_page_50_Picture_10.jpeg" alt=""></p>
<p>GPU Resident Drawer: Selecting <strong>Instanced Drawing</strong> in the Render Pipeline Asset</p>
<p>Upon selecting the Instanced Drawing option you may get a message in the UI warning you that &quot;BatchRenderGroup Variants setting must be &#39;Keep All&#39;&quot;. Adjusting this option in the graphics settings completes the setup for the GPU Resident Drawer.</p>
<p><span id="page-51-0"></span><img src="_page_51_Picture_1.jpeg" alt=""></p>
<p>Set the BatchRenderGroup Varient to <strong>Keep All</strong> within the Graphics settings.</p>
<h4 id="-use-the-frame-debugger-"><strong>Use the Frame Debugger</strong></h4>
<p>The <a href="https://docs.unity3d.com/6000.0/Documentation/Manual/FrameDebugger.html">Frame Debugger</a> shows how each frame is constructed from individual draw calls. This is an invaluable tool for troubleshooting your shader properties that can help you analyze the way your game is rendered.</p>
<p><img src="_page_51_Picture_5.jpeg" alt=""></p>
<p>The Frame Debugger breaks each frame into its separate steps.</p>
<p>New to the Frame Debugger? Check out this introductory tutorial <a href="https://learn.unity.com/tutorial/working-with-the-frame-debugger">here.</a></p>
<p><span id="page-52-0"></span><img src="_page_52_Picture_0.jpeg" alt=""></p>
<h2 id="split-graphics-jobs">Split Graphics Jobs</h2>
<p>This threading mode, supported on multiple desktop and console platforms, aims to improve CPU multi-threading performance. The primary improvement comes from reducing unnecessary synchronization between the main thread (responsible for general game logic and orchestration) and native graphics job threads (responsible for rendering tasks).</p>
<p>The performance improvements from this new threading mode scale with the number of draw calls submitted in each frame. Scenes with more draw calls, e.g., complex scenes with many objects and textures, can see significant performance enhancements.</p>
<h4 id="-avoid-too-many-dynamic-lights-"><strong>Avoid too many dynamic lights</strong></h4>
<p>When developing for XR, mobile, or web platforms, it&#39;s important to limit the use of dynamic lights, especially when using forward rendering. Dynamic lights can significantly impact performance, leading to frame rate drops and increased power consumption, which is particularly critical in resource-constrained environments.</p>
<p>Instead, consider using alternatives such as custom shader effects and light probes for dynamic objects, which can simulate lighting without the heavy performance cost. For static objects, baked lighting is a more efficient option, as it provides high-quality lighting without the runtime overhead. By carefully managing lighting, you can maintain visual quality while optimizing performance across XR, mobile, and web applications.</p>
<p>See this <a href="https://docs.unity3d.com/6000.0/Documentation/Manual/render-pipelines-feature-comparison.html">feature comparison table</a> for the specific limits of URP and Built-in Render Pipeline real-time lights.</p>
<p><span id="page-53-0"></span><img src="_page_53_Picture_0.jpeg" alt=""></p>
<h4 id="-disable-shadows-"><strong>Disable shadows</strong></h4>
<p>Shadow casting can be disabled per MeshRenderer and light. Disable shadows whenever possible to reduce draw calls.</p>
<p>You can also create fake shadows using a blurred texture applied to a simple mesh or quad underneath your characters. Otherwise, you can create blob shadows with custom shaders.</p>
<p><img src="_page_53_Picture_5.jpeg" alt=""></p>
<p>Disable shadow casting to reduce draw calls.</p>
<h4 id="-bake-your-lighting-into-lightmaps-"><strong>Bake your lighting into lightmaps</strong></h4>
<p>Add dramatic lighting to your static geometry using <strong>Global Illumination (GI)</strong>. Mark objects with <strong>Contribute GI</strong> so you can store high-quality lighting in the form of lightmaps.</p>
<p><img src="_page_53_Picture_9.jpeg" alt=""></p>
<p>Enable the <strong>Contribute GI</strong> setting.</p>
<p><span id="page-54-0"></span><img src="_page_54_Picture_0.jpeg" alt=""></p>
<p>Baked shadows and lighting can then render without a performance hit at runtime. The Progressive CPU and GPU Lightmappers can accelerate the baking of Global Illumination.</p>
<table>
<thead>
<tr>
<th>: ロ×<br>· Preview</th>
<th>J v Mesh Renderer</th>
<th></th>
<th>19<br>3</th>
</tr>
</thead>
<tbody>
<tr>
<td>Lightmap for &#39;House01 (1)&#39; 2<br>\$ Baked ▼<br>O</td>
<td>Materials</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>Element O</td>
<td>@ Matr_BuildingsJettys</td>
<td>O</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>T Lighting</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>Cast Shadows</td>
<td>Off</td>
<td></td>
</tr>
<tr>
<td></td>
<td>Contribute Global Illumination</td>
<td>V</td>
<td></td>
</tr>
<tr>
<td></td>
<td>Receive Global Illumination</td>
<td>Lightmaps</td>
<td></td>
</tr>
<tr>
<td></td>
<td>V Lightmapping</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>Scale In Lightmap</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>Stitch Seams</td>
<td>V</td>
<td></td>
</tr>
<tr>
<td></td>
<td>Lightmap Parameters</td>
<td>Scene Default Parameters</td>
<td>· View</td>
</tr>
<tr>
<td></td>
<td>V Baked Lightmap</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td>Lightmap Index: 0</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td>Tiling X: 0.04518224</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td>Tiling Y: 0.04518224</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td>Offset X: 0.2928251<br>Offset Y: 0.770942</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td>Lightmap Resolution: 5</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td>Lightmap Object Scale: 1</td>
</tr>
</tbody>
</table>
<p>To limit memory usage, adjust the <strong>Lightmapping Settings</strong> (<strong>Windows &gt; Rendering &gt; Lighting Settings</strong>) and <strong>Lightmap size</strong>.</p>
<p>Follow the <a href="https://docs.unity3d.com/6000.0/Documentation/Manual/Lightmapping.html">manual guide</a> and <a href="https://unity.com/de/archive/blog/games/lighting-tips-for-mobile-game-development">this article on light optimization</a> to get started with Lightmapping in Unity.</p>
<h2 id="gpu-light-baking">GPU light baking</h2>
<p>The <a href="https://docs.unity3d.com/6000.0/Documentation/Manual/GPUProgressiveLightmapper.html">Progressive GPU Lightmapper i</a>s production-ready in Unity 6. It&#39;s designed to dramatically accelerate lighting data generation by leveraging the power of the GPU, offering faster bake times compared to traditional CPU lightmapping. This system introduces a new light baking backend that simplifies the codebase and delivers more predictable results. Additionally, the minimum GPU requirement has been lowered to 2GB, making this feature accessible to a wider range of developers. It also includes a new API for moving light probe positions at runtime, which is particularly useful for procedurally-generated content, alongside various quality-oflife improvements.</p>
<p><img src="_page_54_Figure_7.jpeg" alt=""></p>
<p>Selecting the Progressive GPU Lightmapper</p>
<p><span id="page-55-0"></span><img src="_page_55_Picture_0.jpeg" alt=""></p>
<h4 id="-use-light-layers-"><strong>Use Light Layers</strong></h4>
<p>For complex scenes with multiple lights, separate your objects using layers, then confine each light&#39;s influence to a specific culling mask.</p>
<p><img src="_page_55_Picture_4.jpeg" alt=""></p>
<p>Layers can limit your light&#39;s influence to a specific culling mask.</p>
<h2 id="adaptive-probe-volumes">Adaptive Probe Volumes</h2>
<p>Unity 6 introduces <a href="https://docs.unity3d.com/Packages/com.unity.render-pipelines.universal@17.0/manual/probevolumes-concept.html">Adaptive Probe Volumes (APVs),</a> which provide a sophisticated solution for handling global illumination in Unity, allowing for dynamic and efficient lighting in complex scenes. APVs can optimize both performance and visual quality, particularly on mobile and lower-end devices, while offering advanced capabilities for high-end platforms.</p>
<p>Adaptive Probe Volumes (APV) in Unity offer a range of features to enhance global illumination, particularly in dynamic and large scenes. URP now supports per-vertex sampling for improved performance on lower-end devices, while VFX particles benefit from indirect lighting baked into probe volumes.</p>
<p><img src="_page_56_Picture_1.jpeg" alt=""></p>
<p>Placing APVs in the oasis environment from the <a href="https://unity.com/demos/urp-3d-sample">URP 3D Sample</a></p>
<p>APV data can be streamed from disk to CPU and GPU, optimizing lighting information for large environments. Developers can bake and blend multiple lighting scenarios, allowing real-time transitions like day/night cycles. The system also supports sky occlusion, integrates with the Ray Intersector API for more efficient probe calculations, and offers control over light probe sample density to reduce light leaking and speed up iterations. The new C# baking API further refines the workflow, enabling independent baking of APV from lightmaps or reflection probes.</p>
<p>To get started, check out the talk <a href="https://www.youtube.com/watch?v=iU7X5xICkc8">Efficient and impactful lighting with Adaptive Probe Volumes</a>  <a href="https://www.youtube.com/watch?v=iU7X5xICkc8">from GDC 2023</a></p>
<table>
<thead>
<tr>
<th>Cighting</th>
<th></th>
<th></th>
<th>-</th>
<th>0<br>×</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>· Lighting</td>
<td></td>
<td></td>
<td></td>
<td>20</td>
<td></td>
</tr>
<tr>
<td></td>
<td>Scene Adaptive Probe Volumes Environment Realtime Lightmaps Baked Lightmaps</td>
<td></td>
<td></td>
<td>0 0</td>
<td></td>
</tr>
<tr>
<td>v Baking</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Baking Mode</td>
<td>Single Scene</td>
<td></td>
<td></td>
<td>D</td>
<td></td>
</tr>
<tr>
<td>Probe Placement</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Probe Offset</td>
<td>X 0</td>
<td>Y O</td>
<td>Z 0</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Min Probe Spacing</td>
<td>1</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Max Probe Spacing</td>
<td>9m</td>
<td>0<br>27m</td>
<td>81m</td>
<td>243m</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Baked Probe Volume data will contain up-to 4 different sizes of Brick.</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>&gt; Renderer Filter Settings</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Sky Occlusion Settings</td>
<td>17</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Sky Occlusion</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Probe Invalidity Settings</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Dilation<br>Virtual Offset</td>
<td>网<br>1</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Validity Threshold</td>
<td></td>
<td></td>
<td></td>
<td>0.75</td>
<td></td>
</tr>
<tr>
<td>Search Distance Multiplier</td>
<td></td>
<td></td>
<td></td>
<td>0.2</td>
<td></td>
</tr>
<tr>
<td>Geometry Bias</td>
<td></td>
<td></td>
<td></td>
<td>0.01</td>
<td></td>
</tr>
<tr>
<td>Ray Origin Bias</td>
<td></td>
<td></td>
<td></td>
<td>@- - 0.001</td>
<td></td>
</tr>
<tr>
<td>Layer Mask</td>
<td>Mixed</td>
<td></td>
<td></td>
<td>&gt;</td>
<td></td>
</tr>
<tr>
<td></td>
<td>Refresh Virtual Offset Debug</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Rendering Layers</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Rendering Layer Masks</td>
<td>0</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>GPU Baking Device</td>
<td>NVIDIA GeForce GTX 970</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>GPU Baking Profile</td>
<td>Automatic</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>Generate Lighting</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Scenario Size</td>
<td></td>
<td>0.0 MB</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Baking Set Size</td>
<td></td>
<td>0.0 MB</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>The Adaptive Probe Volumes window, located in Lighting settings</p>
<p><span id="page-57-0"></span><img src="_page_57_Picture_0.jpeg" alt=""></p>
<h2 id="use-level-of-detail-lod-">Use Level of Detail (LOD)</h2>
<p>As objects move farther from the camera, <a href="https://docs.unity3d.com/Manual/LevelOfDetail.html?">Level of Detail</a> (LOD) can adjust or switch them to use simpler meshes with simpler materials and shaders, to refine GPU performance.</p>
<p><img src="_page_57_Picture_4.jpeg" alt=""></p>
<p>Example of a mesh using an LOD Group</p>
<p><img src="_page_57_Picture_6.jpeg" alt=""></p>
<p>Source meshes, modeled at varying resolutions</p>
<p>See the <a href="https://learn.unity.com/tutorial/working-with-lods-2019-3">Working with LODs</a> course on Unity Learn for more detail.</p>
<p><span id="page-58-0"></span><img src="_page_58_Picture_0.jpeg" alt=""></p>
<h2 id="use-occlusion-culling-to-remove-hidden-objects">Use occlusion culling to remove hidden objects</h2>
<p>Objects hidden behind other objects can potentially still render and cost resources. Use occlusion culling to discard them.</p>
<p>While frustum culling outside the camera view is automatic, occlusion culling is a baked process. Simply mark your objects as <strong>Static Occluders</strong> or <strong>Occludees</strong>, then bake via <strong>Window &gt; Rendering &gt; Occlusion Culling</strong>. Though not necessary for every scene, culling can improve performance in specific cases, so be sure to profile before and after enabling occlusion culling to check if it has improved performance.</p>
<p>Check out the <a href="https://learn.unity.com/tutorial/working-with-occlusion-culling">Working with Occlusion Culling</a> tutorial for more information.</p>
<h2 id="gpu-occlusion-culling">GPU occlusion culling</h2>
<p><a href="https://docs.unity3d.com/Packages/com.unity.render-pipelines.universal@17.0/manual/gpu-culling.html">GPU occlusion culling</a> significantly improves rendering performance, especially in scenes with complex geometries and many occluded objects. GPU occlusion culling boosts the performance of GameObjects by reducing the amount of overdraw for each frame, which means the renderer is not wasting resources drawing things that are not seen, an issue that traditionally has been a significant performance bottleneck in 3D environments. The key features of GPU occlusion culling include:</p>
<ul>
<li><ol>
<li><strong>GPU acceleration</strong>: Unlike previous versions that relied heavily on CPU for occlusion culling, Unity 6 leverages GPU acceleration. This shift allows for more efficient real-time calculations, reducing the overhead on the CPU and enabling more complex scenes without sacrificing performance.</li>
</ol>
</li>
<li><ol>
<li><strong>Integration with GPU Resident Drawer</strong>: The GPU occlusion culling works in tandem with the GPU Resident Drawer, which handles large sets of objects and their visibility, further optimizing rendering pipelines for both static and dynamic objects.</li>
</ol>
</li>
<li><ol>
<li><strong>Dynamic and static object culling:</strong> Unity 6&#39;s occlusion culling system can manage both static and dynamic objects more effectively. Dynamic objects are now culled using a portal-based system, which ensures that only the visible objects are processed, even when they move within the scene.</li>
</ol>
</li>
<li><ol>
<li><strong>Baking and real-time adjustments:</strong> Developers can bake occlusion data in the Editor, which is then used at runtime. This process divides the scene into cells and computes visibility between them, allowing for real-time adjustments as the camera moves. The system also supports visualizing occlusion culling in the Editor, helping developers optimize their scenes better.</li>
</ol>
</li>
<li><ol>
<li><strong>Memory management:</strong> Unity 6 provides tools to manage the memory footprint of occlusion data, allowing fine-tuning of the occlusion culling process to balance performance with memory usage.</li>
</ol>
</li>
</ul>
<p>To activate GPU occlusion culling locate the Render Pipeline Asset and toggle the <strong>GPU Occlusion</strong> check box.</p>
<p><span id="page-59-0"></span><img src="_page_59_Picture_1.jpeg" alt=""></p>
<p>The GPU Occlusion Culling option in the Render Pipeline Asset</p>
<h2 id="avoid-mobile-native-resolution">Avoid mobile native resolution</h2>
<p>With phones and tablets becoming increasingly advanced, newer devices tend to sport very high resolutions.</p>
<p>You can use <strong>Screen.SetResolution(width, height, false)</strong> to lower the output resolution and regain some performance. Profile multiple resolutions to find the best balance between quality and speed.</p>
<h2 id="limit-use-of-cameras">Limit use of cameras</h2>
<p>Each enabled camera incurs some overhead, whether it&#39;s doing meaningful work or not. Only use Camera components required for rendering. On lower-end mobile platforms, each camera can use up to 1 ms of CPU time.</p>
<h2 id="spatial-temporal-post-processing">Spatial-Temporal Post-Processing</h2>
<p>Spatial-Temporal Post-Processing (STP) is designed to enhance visual quality across a wide range of platforms, from mobile devices to consoles and PCs. STP is a spatio-temporal antialiasing upscaler that works with both HDRP and URP render pipelines, offering high-quality content scaling without the need for changes to existing content. This solution is optimized</p>
<p><img src="_page_60_Picture_0.jpeg" alt=""></p>
<p>for GPU performance, ensuring faster rendering times and making it easier to achieve high performance while maintaining visual quality.</p>
<p>To enable STP in the URP:</p>
<ul>
<li>Select the active URP Asset in the Project window.</li>
<li>In the Inspector navigate to <strong>Quality &gt; Upscaling Filter</strong>, and select <strong>Spatial-Temporal Post-Processing</strong>.</li>
</ul>
<p><img src="_page_60_Picture_6.jpeg" alt=""></p>
<p>Enabling STP within the URP Asset</p>
<h2 id="-span-id-page-61-0-span-shaders"><span id="page-61-0"></span>Shaders</h2>
<h2 id="keep-shaders-simple-and-optimized">Keep shaders simple and optimized</h2>
<p>URP offers a range of lightweight Lit and Unlit shaders that are optimized for mobile platforms, making them a great starting point for your web, mobile, and XR projects. To maximize performance, keep your shader variations to a minimum, as multiple variants can impact runtime memory usage, particularly on resource-constrained devices.</p>
<p>If the default URP shaders don&#39;t meet your specific needs, you can customize them using <a href="https://docs.unity3d.com/Packages/com.unity.shadergraph@17.0/manual/index.html">Shader Graph</a>, which allows you to visually design and optimize shaders for your project. Here are a few shader optimization tips:</p>
<ul>
<li><strong>Minimize calculations</strong>: Simplify shaders by reducing the number of operations, especially in fragment shaders, where each pixel requires computation. Avoid complex mathematical operations and heavy branching logic (e.g., if statements), which can be taxing on the GPU, particularly in mobile and XR applications.</li>
<li><strong>Use combined textures</strong>: Utilize combined textures like occlusion, roughness, and metallic (ORM) maps to reduce the number of texture lookups. This approach consolidates multiple maps into a single texture, lowering the workload on the GPU, which is crucial for maintaining performance on mobile, web, and XR platforms.</li>
<li><strong>Optimize Shader Graph</strong>: When using Shader Graph, focus on streamlining shader logic to enhance performance. This is particularly important for mobile and XR applications, where the efficiency of each shader directly impacts overall performance.</li>
</ul>
<p><span id="page-62-0"></span>— <strong>Profile regularly</strong>: Continuously test and profile your shaders on the target devices, whether web, mobile, or XR, to ensure they meet performance requirements. Regular profiling helps you catch potential issues early and optimize accordingly for each platform&#39;s specific needs.</p>
<p><img src="_page_62_Figure_2.jpeg" alt=""></p>
<p>Create custom shaders with Shader Graph.</p>
<h2 id="minimize-overdraw-and-alpha-blending">Minimize overdraw and alpha blending</h2>
<p>Avoid drawing unnecessary transparent or semi-transparent images, and do not overlap barely visible images or effects. Mobile platforms are impacted by the resulting overdraw and alpha blending. You can check overdraw using the <a href="https://docs.unity3d.com/6000.0/Documentation/Manual/RenderDocIntegration.html">RenderDoc</a> graphics debugger. You can also utilize the <a href="https://docs.unity3d.com/Packages/com.unity.render-pipelines.universal@17.0/manual/features/rendering-debugger.html">Rendering Debugger,</a> which lets you visualize various lighting, rendering, and material properties. The visualizations help you identify rendering issues and optimize scenes and rendering configurations.</p>
<h2 id="-span-id-page-63-0-span-limit-post-processing-effects"><span id="page-63-0"></span>Limit post-processing effects</h2>
<p>Fullscreen <a href="https://docs.unity3d.com/Packages/com.unity.render-pipelines.universal@17.0/manual/integration-with-post-processing.html">post-processing</a> effects like glows can dramatically slow down performance. Use them cautiously in your title&#39;s art direction. Post-processing can be a common source for performance bottlenecks on mobile, XR, and web so be extra careful to benchmark and make artistic choices accordingly.</p>
<p><img src="_page_63_Figure_3.jpeg" alt=""></p>
<p>Keep post-processing effects simple in mobile applications.</p>
<h2 id="be-careful-with-renderer-material">Be careful with Renderer.material</h2>
<p>Accessing <strong>Renderer.material</strong> in scripts duplicates the material and returns a reference to the new copy. This breaks any existing batch that already includes the material. If you wish to access the batched object&#39;s material, use <strong><a href="https://docs.unity3d.com/6000.0/Documentation/ScriptReference/Renderer-sharedMaterial.html?">Renderer.sharedMaterial</a></strong> instead.</p>
<h2 id="optimize-skinnedmeshrenderers">Optimize SkinnedMeshRenderers</h2>
<p>Rendering skinned meshes is expensive. Make sure that every object using a <strong>SkinnedMeshRenderer</strong> requires it. If a GameObject only needs animation some of the time, use the <strong>BakeMesh</strong> function to freeze the skinned mesh in a static pose, then swap to a simpler <strong>MeshRenderer</strong> at runtime.</p>
<h2 id="-span-id-page-64-0-span-minimize-reflection-probes"><span id="page-64-0"></span>Minimize reflection probes</h2>
<p>A <a href="https://docs.unity3d.com/6000.0/Documentation/Manual/class-ReflectionProbe.html?">Reflection Probe</a> component can create realistic reflections, but can be very costly in terms of batches. Use low-resolution cubemaps, culling masks, and texture compression to improve runtime performance.</p>
<h2 id="system-metrics-mali">System Metrics Mali</h2>
<p>You can also leverage the System Metrics Mali package to access low-level system or hardware performance metrics on devices that use ARM GPUs. This includes being able to monitor lowlevel GPU metrics in the Unity Profiler, use the Recorder API to access low-level GPU metrics at runtime, and automate performance testing with continuous integration test runs.</p>
<table>
<thead>
<tr>
<th>Co Profiler</th>
<th></th>
<th></th>
<th></th>
<th></th>
<th>: ■×</th>
</tr>
</thead>
<tbody>
<tr>
<td>Profiler Modules</td>
<td></td>
<td></td>
<td></td>
<td>▼ Play Mode ▼ ⑨ √ ▶ ▶ · · · · · · · · · · · · · · · · · · · · · · · · · · · · · · · · · · · · · · · · · · · · · · · · · · · · · · · · · · · · · · · · · · · · · · · · · · · ·</td>
<td></td>
</tr>
<tr>
<td>* Mali System Metrics<br>GPU Cycles<br>· Vertex And Compute Cycles<br>Fragment Cycles<br>· Shader Core Cycles</td>
<td></td>
<td></td>
<td></td>
<td>107.26k m<br>2.03M<br>1.92M<br>5.95M</td>
<td></td>
</tr>
<tr>
<td>GPU Cycles</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Total<br>Vertex And Compute Cycles<br>Fragment Cycles</td>
<td>2.03M<br>107.26k<br>1.92M</td>
<td>5.29%<br>94.71%</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Shader Core Cycles</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Total</td>
<td>5.95M</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Shader Arithmetic Cycles</td>
<td>5.58M</td>
<td>93.90%</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Shader Load/Store Cycles<br>Shader Texture Cycles</td>
<td>60.45k<br>329.16k</td>
<td>1.02%<br>5.54%</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Tiling<br>liles</td>
<td>10.00K</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Unchanged Eliminated Tiles</td>
<td>9.98K</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Pixels</td>
<td>2.58M</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Cycles Per Pixel</td>
<td>0.79</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>GPU Cache And External Memory Usage</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Cache Read Lookups</td>
<td>151.59k</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Memory Read Accesses</td>
<td>8.45k</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Memory Read Stalled Cycles</td>
<td>16.02K</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Memory Read Bytes</td>
<td>0.5 MB</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Cache Write Lookups</td>
<td>186.19k<br>163.49K</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Memory Write Accesses<br>Memory Write Stalled Cycles</td>
<td>279.11k</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Memory Write Bytes</td>
<td>9.9 MB</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>GPU Z Tests</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Early Z Tests</td>
<td>643.75k</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Early Z Kills</td>
<td>0</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Late Z Tests</td>
<td>0</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Late Z Kills</td>
<td>0</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>All Z Tests Kill Percentage</td>
<td>0.00%</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Shader Instructions And Jobs</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Instructions</td>
<td>5.58M</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Diverged Instructions<br>Vertex And Compute Jobs</td>
<td>844<br>11</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Fragment Jobs</td>
<td>3</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Shader Parallelism</td>
<td>99.98%</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>Mali System Metrics Profiler Module</p>
<p><img src="_page_65_Picture_0.jpeg" alt=""></p>
<p>Learn much more about lighting workflows in Unity from these guides:</p>
<ul>
<li><a href="https://unity.com/resources/introduction-to-urp-advanced-creators-unity-6">Introduction to the Universal Render Pipeline for advanced Unity creators</a></li>
<li><a href="https://unity.com/how-to/2d-light-shadow-techniques-in-the-universal-render-pipeline">2D light and shadow techniques in URP</a></li>
<li><a href="https://www.youtube.com/watch?v=R1B5Aw8oBGg">Lighting and AI techniques for your 2D game</a></li>
<li><a href="https://unity.com/resources/the-universal-render-pipeline-cookbook-unity-2022-lts-edition?isGated=false">Recipes for popular visual effects in URP</a></li>
</ul>
<h1 id="-span-id-page-66-0-span-user-interface"><span id="page-66-0"></span>User interface</h1>
<p>Unity offers two UI systems, the older Unity UI and the new UI Toolkit. <a href="https://docs.unity3d.com/6000.0/Documentation/Manual/UIElements.html">UI Toolkit</a> is intended to become the recommended UI system. It&#39;s tailored for maximum performance and reusability, with workflows and authoring tools inspired by standard web technologies, meaning UI designers and artists will find it familiar if they already have experience designing web pages.</p>
<p>However, as of Unity 6, UI Toolkit does not have some features that <a href="https://docs.unity3d.com/6000.0/Documentation/Manual/com.unity.ugui.html">Unity UI</a> and <a href="https://docs.unity3d.com/6000.0/Documentation/Manual/GUIScriptingGuide.html">Immediate</a>  <a href="https://docs.unity3d.com/6000.0/Documentation/Manual/GUIScriptingGuide.html">Mode GUI (IMGUI)</a> support. Unity UI and IMGUI are more appropriate for certain use cases and are required to support legacy projects. See the <a href="https://docs.unity3d.com/6000.0/Documentation/Manual/UI-system-compare.html">Comparison of UI systems in Unity</a> for more information.</p>
<h2 id="ugui-performance-optimization-tips">UGUI performance optimization tips</h2>
<p>Unity UI (UGUI) can often be a source of performance issues. The Canvas component generates and updates meshes for the UI elements and issues draw calls to the GPU. Its functioning can be expensive, so keep the following factors in mind when working with it.</p>
<h4 id="-divide-your-canvases-"><strong>Divide your Canvases</strong></h4>
<p>If you have one large Canvas with thousands of elements, updating a single UI element forces the whole Canvas to update, which can potentially generate a CPU spike.</p>
<p>Take advantage of UGUI&#39;s ability to support multiple Canvases. Divide UI elements based on how frequently they need to be refreshed. Keep static UI elements on a separate Canvas, and dynamic elements that update at the same time on smaller sub-canvases.</p>
<p>Ensure that all UI elements within each Canvas have the same Z value, materials, and textures.</p>
<p><span id="page-67-0"></span><img src="_page_67_Picture_0.jpeg" alt=""></p>
<h4 id="-hide-invisible-ui-elements-"><strong>Hide invisible UI elements</strong></h4>
<p>You might have UI elements that only appear sporadically in the game (e.g., a health bar that appears when a character takes damage). If your invisible UI element is active, it might still be using draw calls. Explicitly disable any invisible UI components and re-enable them as needed.</p>
<p>If you only need to turn off the Canvas&#39;s visibility, disable the Canvas component rather than the whole GameObject. This can prevent your game from having to rebuild meshes and vertices when you re-enable it.</p>
<h4 id="-limit-graphicraycasters-and-disable-raycast-target-"><strong>Limit GraphicRaycasters and disable Raycast Target</strong></h4>
<p>Input events like onscreen touches or clicks require the <strong>GraphicRaycaster</strong> component. This simply loops through each input point onscreen and checks if they&#39;re within a UI&#39;s RectTransform.</p>
<p>Remove the default <strong>GraphicRaycaster</strong> from the top Canvas in the hierarchy. Instead, add the <strong>GraphicRaycaster</strong> exclusively to the individual elements that need to interact (buttons, scrollrects, and so on).</p>
<table>
<thead>
<tr>
<th>G &amp; Graphic Raycaster</th>
<th></th>
<th>2</th>
<th>14</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>Script</td>
<td>GraphicRaycaster</td>
<td></td>
<td></td>
<td>0</td>
</tr>
<tr>
<td>Ignore Reversed Graphics</td>
<td>&gt;</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Blocking Objects</td>
<td>None</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Blocking Mask</td>
<td>Everything</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>Disable Reversed Graphics, which is active by default.</p>
<p>In addition, disable <strong>Raycast Target</strong> on all UI text and images that don&#39;t need it. If the UI is complex with many elements, all of these small changes can reduce unnecessary computation.</p>
<table>
<thead>
<tr>
<th>▼ 2 / Image</th>
<th></th>
<th>9<br>-</th>
</tr>
</thead>
<tbody>
<tr>
<td>Source Image</td>
<td>@BoatAttack-logo-W</td>
<td>O</td>
</tr>
<tr>
<td>Color</td>
<td></td>
<td>0</td>
</tr>
<tr>
<td>Material</td>
<td>None (Material)</td>
<td>O</td>
</tr>
<tr>
<td>Raycast Target</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Raycast Padding</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Maskable</td>
<td>&gt;</td>
<td></td>
</tr>
<tr>
<td>Image Type</td>
<td>Simple</td>
<td></td>
</tr>
<tr>
<td>Use Sprite Mesh</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Preserve Aspect</td>
<td>&gt;</td>
</tr>
</tbody>
</table>
<p>Disable Raycast Target if possible.</p>
<p><span id="page-68-0"></span><img src="_page_68_Picture_0.jpeg" alt=""></p>
<h4 id="-avoid-layout-groups-"><strong>Avoid Layout Groups</strong></h4>
<p>Layout Groups update inefficiently, so use them sparingly. However, if your content isn&#39;t dynamic, it&#39;s generally best to avoid using them and use anchors for proportional layouts instead. Otherwise, create custom code to disable the <a href="https://docs.unity3d.com/Packages/com.unity.ugui@3.0/manual/UIAutoLayout.html">Layout Group</a> components after they set up the UI.</p>
<p>If you do need to use Layout Groups (Horizontal, Vertical, Grid) for your dynamic elements, avoid nesting them to improve performance.</p>
<table>
<thead>
<tr>
<th>J √ Grid Layout Group<br>&gt;</th>
<th></th>
<th></th>
<th></th>
<th>2</th>
<th>14</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>Padding<br>A</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Cell Size</td>
<td>X 100</td>
<td></td>
<td>Y 100</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Spacing</td>
<td>X 0</td>
<td>Y O</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Start Corner</td>
<td>Upper Left</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Start Axis</td>
<td>Horizontal</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Child Alignment</td>
<td>Upper Left</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>D</td>
</tr>
<tr>
<td>Constraint</td>
<td>Flexible</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>Layout Groups can lower performance, especially when nested.</p>
<h4 id="-avoid-large-list-and-grid-views-"><strong>Avoid large List and Grid views</strong></h4>
<p>Large List and Grid views are expensive. If you need to create a large List or Grid view (e.g., an inventory screen with hundreds of items), consider reusing a smaller pool of UI elements rather than creating a UI element for every item. Check out this sample <a href="https://github.com/boonyifei/ScrollList">GitHub project</a> to see this in action.</p>
<h4 id="-avoid-numerous-overlaid-elements-"><strong>Avoid numerous overlaid elements</strong></h4>
<p>Layering lots of UI elements (e.g., cards stacked in a card battle game) creates overdraw. Customize your code to merge layered elements at runtime into fewer elements and batches.</p>
<h4 id="-use-multiple-resolutions-and-aspect-ratios-"><strong>Use multiple resolutions and aspect ratios</strong></h4>
<p>With mobile devices now using very different resolutions and screen sizes, create <a href="https://docs.unity3d.com/Packages/com.unity.ugui@3.0/manual/HOWTO-UIMultiResolution.html">alternate</a>  <a href="https://docs.unity3d.com/Packages/com.unity.ugui@3.0/manual/HOWTO-UIMultiResolution.html">versions of the UI</a> to provide the best experience on each device.</p>
<p>Use the Device Simulator to preview the UI across a wide range of supported devices. You can also create virtual devices in <a href="https://developer.apple.com/library/archive/documentation/IDEs/Conceptual/iOS_Simulator_Guide/GettingStartedwithiOSSimulator/GettingStartedwithiOSSimulator.html#//apple_ref/doc/uid/TP40012848-CH5-SW10">XCode</a> and <a href="https://developer.android.com/studio/run/managing-avds">Android Studio.</a></p>
<p><span id="page-69-0"></span><img src="_page_69_Picture_1.jpeg" alt=""></p>
<p>Preview a variety of screen formats using the Device Simulator.</p>
<h4 id="-when-using-a-fullscreen-ui-hide-everything-else-"><strong>When using a fullscreen UI, hide everything else</strong></h4>
<p>If your pause or start screen covers everything else in the scene, disable the camera that is rendering the 3D scene. Similarly, disable any background Canvas elements hidden behind the top Canvas.</p>
<p>Consider lowering the <strong>Application.targetFrameRate</strong> during a fullscreen UI, since you should not need to update at 60 fps.</p>
<h4 id="-assign-the-camera-to-world-space-and-camera-space-canvases-"><strong>Assign the Camera to World Space and Camera Space Canvases</strong></h4>
<p>Leaving the <strong>Event</strong> or <strong>Render Camera</strong> field blank forces Unity to fill in <strong>Camera.main</strong>, which is unnecessarily expensive.</p>
<p>Consider using <strong>Screen Space – Overlay</strong> for your Canvas <strong>RenderMode</strong> if possible, as that does not require a camera.</p>
<table>
<thead>
<tr>
<th>C / Canvas</th>
<th></th>
<th>S<br>t<br></th>
</tr>
</thead>
<tbody>
<tr>
<td>Render Mode</td>
<td>World Space</td>
<td></td>
</tr>
<tr>
<td>Event Camera</td>
<td>Main Camera (Camera)</td>
<td>O</td>
</tr>
<tr>
<td>Sorting Layer</td>
<td>Default</td>
<td>1</td>
</tr>
<tr>
<td>Order in Layer</td>
<td>0</td>
<td></td>
</tr>
<tr>
<td>Additional Shader Channels Mixed</td>
<td></td>
</tr>
</tbody>
</table>
<p>When using World Space Render Mode, make sure to fill in the Event Camera.</p>
<h2 id="-span-id-page-70-0-span-ui-toolkit-performance-optimization-tips"><span id="page-70-0"></span>UI Toolkit performance optimization tips</h2>
<p>UI Toolkit offers improved performance over Unity UI, is tailored for maximum performance and reusability, and provides workflows and authoring tools inspired by standard web technologies. One of its key benefits is that it uses a highly optimized rendering pipeline that is specifically designed for UI elements.</p>
<p>Here are some general recommendations for optimizing performance of your UI with UI Toolkit:</p>
<h2 id="use-efficient-layouts">Use efficient layouts</h2>
<p>Efficient layouts refer to using <a href="https://docs.unity3d.com/6000.0/Documentation/Manual/UIE-LayoutEngine.html">layout groups</a> provided by UI Toolkit, such as Flexbox, instead of manually positioning and resizing UI elements. Layout groups handle the layout calculations automatically, which can significantly improve performance. They ensure that UI elements are arranged and sized correctly based on the specified layout rules. By utilizing efficient layouts, you avoid the overhead of manual layout calculations and achieve consistent and optimized UI rendering.</p>
<h2 id="avoid-expensive-operations-in-update">Avoid expensive operations in Update</h2>
<p>Minimize the amount of work performed in Update methods, especially heavy operations like UI element creation, manipulation, or calculation. Perform these operations sparingly or during initialization when possible, since the update method is called once per frame.</p>
<p><span id="page-71-0"></span><img src="_page_71_Picture_0.jpeg" alt=""></p>
<h2 id="optimize-event-handling">Optimize event handling</h2>
<p>Be mindful of event subscriptions and unregister them when no longer needed. Excessive event handling can impact performance, so ensure you only subscribe to events that are necessary.</p>
<h2 id="optimize-style-sheets">Optimize style sheets</h2>
<p>Be mindful of the number of style classes and selectors used in your style sheets. Large style sheets with numerous rules can impact performance. Keep your style sheets lean and avoid unnecessary complexity.</p>
<h2 id="profile-and-optimize">Profile and optimize</h2>
<p>Use Unity&#39;s profiling tools to identify performance bottlenecks in your UI and spot areas that can be optimized further, such as inefficient layout calculations or excessive redraws.</p>
<h2 id="test-on-target-platforms">Test on target platforms</h2>
<p>Test your UI performance on target platforms to ensure optimal performance across different devices. Performance can vary based on hardware capabilities, so consider the target platform when optimizing your UI.</p>
<p>Remember, performance optimization is an iterative process. Continuously profile, measure, and optimize your UI code to ensure it runs smoothly and efficiently.</p>
<h2 id="-span-id-page-72-0-span-audio"><span id="page-72-0"></span>Audio</h2>
<p>Though audio is not typically a performance bottleneck, you can still optimize to save memory.</p>
<p><img src="_page_72_Picture_2.jpeg" alt=""></p>
<p>Optimize the Import Settings of your AudioClips.</p>
<h2 id="-span-id-page-73-0-span-make-sound-clips-mono-when-possible"><span id="page-73-0"></span>Make sound clips mono when possible</h2>
<p>If you are using 3D spatial audio, author your sound clips as mono (single channel) or enable the Force To Mono setting. Otherwise, a multichannel sound used positionally at runtime will be flattened to a mono source, thus increasing CPU cost and wasting memory.</p>
<h2 id="use-original-uncompressed-wav-files-as-your-source-assets">Use original uncompressed WAV files as your source assets</h2>
<p>If you use any compressed format (such as MP3 or Vorbis), Unity will decompress it, then recompress it during build time. This results in two lossy passes, degrading the final quality.</p>
<h2 id="compress-the-clip-and-reduce-the-compression-bitrate">Compress the clip and reduce the compression bitrate</h2>
<p>Reduce the size of your clips and memory usage with compression:</p>
<ul>
<li>Use <strong>Vorbis</strong> for most sounds (or <strong>MP3</strong> for sounds not intended to loop).</li>
<li>Use <strong>ADPCM</strong> for short, frequently used sounds (e.g., footsteps, gunshots). This shrinks the files compared to uncompressed PCM, but is quick to decode during playback.</li>
</ul>
<p>Sound effects on mobile devices should be 22,050 Hz at most. Using lower settings usually has minimal impact on the final quality; your own ears can help you judge for yourself.</p>
<p><span id="page-74-0"></span><img src="_page_74_Picture_0.jpeg" alt=""></p>
<h2 id="choose-the-proper-load-type">Choose the proper Load Type</h2>
<p>The setting varies by clip size, see the following table for more information:</p>
<table>
<thead>
<tr>
<th>Clip size</th>
<th>Example usage</th>
<th>Load type settings</th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>Small (&lt; 200<br>KB)</td>
<td>Noisy sound<br>effects<br>(footsteps,<br>gunshots), UI<br>sounds</td>
<td>Use Decompress on Load. This incurs a small CPU cost<br>to decompress a sound into raw 16-bit PCM audio data,<br>but will be the most performant at runtime.<br>Or set to Compressed In Memory and set<br>Compression Format to ADPCM. This offers a<br>fixed 3.5:1 compression ratio and is inexpensive to<br>decompress in real-time.</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Medium (&gt;=<br>200 KB)</td>
<td>Dialog, short<br>music, medium/<br>non-noisy<br>sounds effects</td>
<td>Optimal Load Type depends on the project&#39;s priorities.<br>If reducing memory usage is the priority, select<br>Compressed In Memory.<br>If CPU usage is a concern, clips should be set to<br>Decompress On Load.</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Large (&gt;<br>350-400<br>KB)</td>
<td>Background<br>music, ambient<br>background<br>noise, long<br>dialog</td>
<td>Set to Streaming. Streaming has a 200 KB overhead, so<br>it is only suitable for sufficiently large AudioClips.</td>
<td></td>
</tr>
</tbody>
</table>
<h2 id="unload-muted-audiosources-from-memory">Unload muted AudioSources from memory</h2>
<p>When implementing a mute button, don&#39;t simply set the volume to 0. You can Destroy the AudioSource component to unload it from memory, provided the player does not need to toggle this on and off very often.</p>
<h2 id="use-the-sample-rate-setting">Use the Sample Rate Setting</h2>
<p>Set the <strong>Sample Rate Setting</strong> to Optimize Sample Rate or Override Sample Rate.</p>
<p>For mobile platforms, 22050 Hz should be sufficient. Use 44100Hz (i.e. CD-quality) sparingly. 48000Hz is excessive.</p>
<h1 id="-span-id-page-75-0-span-animation"><span id="page-75-0"></span>Animation</h1>
<p>The following tips will help you when working with animation in Unity. For a comprehensive guide through the animation system, download the free e-book <em><a href="https://unity.com/resources/definitive-guide-animation-unity-2022-lts-ebook">The definitive guide to</a>  <a href="https://unity.com/resources/definitive-guide-animation-unity-2022-lts-ebook">animation in Unity</a></em>.</p>
<h3 id="use-generic-rather-than-humanoid-rigs">Use generic rather than humanoid rigs</h3>
<p>By default, Unity imports animated models with the generic rig, but developers often switch to the humanoid rig when animating a character. Be aware of these issues with rigs:</p>
<ul>
<li>Use a generic rig whenever possible. Humanoid rigs calculate inverse kinematics and animation retargeting each frame, even when not in use. Thus, they consume 30–50% more CPU time than their equivalent generic rigs.</li>
<li>When importing humanoid animation, use an Avatar Mask to remove IK Goals or finger animation if you don&#39;t need them.</li>
<li>With Generic Rigs, using root motion is more expensive than not using it. If your animations don&#39;t use root motion, do not specify a root bone.</li>
</ul>
<p>Generic rigs use less CPU time than humanoid rigs.</p>
<p><img src="_page_75_Picture_8.jpeg" alt=""></p>
<h2 id="-span-id-page-76-0-span-use-alternatives-for-simple-animation"><span id="page-76-0"></span>Use alternatives for simple animation</h2>
<p>Animators are primarily intended for humanoid characters. However, they are often repurposed to animate single values (e.g., the alpha channel of a UI element). Avoid overusing Animators, particularly in conjunction with UI elements, since they come with extra overhead.</p>
<p>The current animation system is optimized for animation blending and more complex setups. It has temporary buffers used for blending, and there is additional copying of the sampled curve and other data.</p>
<p>Also, if possible, consider not using the animation system at all. Create <a href="https://easings.net">easing functions</a> or use a third-party tweening library where possible (e.g., <a href="https://assetstore.unity.com/packages/tools/animation/dotween-hotween-v2-27676?">DOTween</a>). These can achieve very natural-looking interpolation with mathematical expressions.</p>
<h2 id="avoid-scale-curves">Avoid scale curves</h2>
<p>Animating scale curves is more expensive than animating translation and rotation curves. To improve performance, avoid scale animations.</p>
<p> Note: This does not apply to constant curves (curves that have the same value for the length of the <a href="https://docs.unity3d.com/6000.0/Documentation/Manual/class-AnimationClip.html?">animation clip)</a>. Constant curves are optimized, and these are less expensive than normal curves.</p>
<h2 id="update-only-when-visible">Update only when visible</h2>
<p>Set the animators&#39;s <a href="https://docs.unity3d.com/6000.0/Documentation/Manual/class-Animator.html?">Culling Mode</a> to <strong>Based on Renderers</strong>, and disable the <a href="https://docs.unity3d.com/6000.0/Documentation/Manual/class-SkinnedMeshRenderer.html?">Skinned Mesh</a>  <a href="https://docs.unity3d.com/6000.0/Documentation/Manual/class-SkinnedMeshRenderer.html?">Renderer&#39;s</a> <strong>Update When Offscreen</strong> property. This saves Unity from updating animations when the character is not visible.</p>
<h2 id="optimize-workflow">Optimize workflow</h2>
<p>Other optimizations are possible at the scene level:</p>
<ul>
<li>Use hashes instead of strings to query the Animator.</li>
<li>Implement a small AI Layer to control the Animator. You can make it provide simple callbacks for OnStateChange, OnTransitionBegin, and other events.</li>
<li>Use State Tags to easily match your AI state machine to the Unity state machine.</li>
<li>Use additional curves to simulate events.</li>
<li>Use additional curves to mark up your animations, for example in conjunction with <a href="https://docs.unity3d.com/6000.0/Documentation/Manual/TargetMatching.html?">target</a>  <a href="https://docs.unity3d.com/6000.0/Documentation/Manual/TargetMatching.html?">matching</a>.</li>
</ul>
<p><span id="page-77-0"></span><img src="_page_77_Picture_0.jpeg" alt=""></p>
<h4 id="-separate-animating-hierarchies-"><strong>Separate animating hierarchies</strong></h4>
<p>Ensure that animating hierarchies do not share a common parent (unless that parent is the root of the scene). This separation prevents threading issues when writing the result of animation back to GameObjects, which can cause significant performance penalties.</p>
<h4 id="-minimize-binding-costs-"><strong>Minimize binding costs</strong></h4>
<p>Be aware of the high costs associated with binding operations in the animation system. To optimize performance, avoid frequently adding clips, adding or removing GameObjects and components, and enabling or disabling objects during runtime which generally require rebinding. All of these operations are computationally expensive.</p>
<h4 id="-avoid-using-component-based-constraints-on-deep-hierarchies-"><strong>Avoid using component-based constraints on deep hierarchies</strong></h4>
<p>Avoid using component-based constraints on deep hierarchies, such as characters with complex structures as this can result in poor performance.</p>
<h4 id="-consider-performance-implications-of-animation-rigging-"><strong>Consider performance implications of animation rigging</strong></h4>
<p>When using animation rigging, be mindful of the performance overhead introduced by each constraint. This consideration is important when working with humanoid models. Whenever possible, utilize the built-in IK (Inverse Kinematics) pass in the Humanoid rig to improve performance.</p>
<h1 id="-span-id-page-78-0-span-physics"><span id="page-78-0"></span>Physics</h1>
<p>Physics can create intricate gameplay, but this comes with a performance cost. When you know these costs, you can tweak the simulation to manage them appropriately. These tips can help you stay within your target frame rate and create smooth playback with Unity&#39;s built-in physics (NVIDIA PhysX).</p>
<h2 id="simplify-colliders">Simplify colliders</h2>
<p>Mesh colliders can be expensive. Substitute more complex mesh colliders with primitive or simplified mesh colliders to approximate the original shape.</p>
<p><img src="_page_78_Picture_4.jpeg" alt=""></p>
<p>Use primitives or simplified meshes for colliders.</p>
<p><span id="page-79-0"></span><img src="_page_79_Picture_0.jpeg" alt=""></p>
<h2 id="optimize-your-settings">Optimize your settings</h2>
<p>In the <a href="https://docs.unity3d.com/6000.0/Documentation/Manual/class-PlayerSettings.html">PlayerSettings,</a> check <strong>Prebake Collision Meshes</strong> whenever possible.</p>
<table>
<thead>
<tr>
<th>Optimization</th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>Prebake Collision Meshes*</td>
<td>D</td>
<td></td>
</tr>
<tr>
<td>Keep Loaded Shaders Alive*</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Preloaded Assets*</td>
<td></td>
<td></td>
</tr>
<tr>
<td>AOT Compilation Options*</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Strip Engine Code*</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Managed Stripping Level</td>
<td>Low</td>
<td>D</td>
</tr>
<tr>
<td>Script Call Optimization*</td>
<td>Slow and Safe</td>
<td>&gt;</td>
</tr>
<tr>
<td>Vertex Compression *</td>
<td>Mixed</td>
<td>V</td>
</tr>
<tr>
<td>Optimize Mesh Data*</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Texture MipMap Stripping*</td>
<td></td>
</tr>
</tbody>
</table>
<p>Enable Prebake Collision Meshes</p>
<p>Make sure that you edit your Physics settings (<strong>Project Settings &gt; Physics</strong>) as well. Simplify your Layer Collision Matrix wherever possible.</p>
<table>
<thead>
<tr>
<th>Preject Settings</th>
<th></th>
<th></th>
<th></th>
<th>0<br>×</th>
</tr>
</thead>
<tbody>
<tr>
<td>Project Settings</td>
<td></td>
<td></td>
<td>A</td>
<td></td>
</tr>
<tr>
<td>Adaptive Petformance<br>Audio</td>
<td>Physics Settings</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Burst AOT Settings<br>Editor<br>Graphics<br>In-Editor Tutorials<br>Input Manager<br>v Incut System Package<br>Settings<br>Memory Settings<br>Package Manager<br>v Physics<br>Settings<br>Physics 2D<br>Player<br>Preset Manager<br>y Quality<br>HORP<br>Scene Template<br>Script Execution Order<br>Services<br>ShaderGraph<br>Tags and Layers<br>TextMesh Pro<br>Time<br>Timeling<br>Ul Toolkit<br>Version Control<br>VFX<br>Visual Scripting<br>XR Plugin Management</td>
<td>Shared<br>Game Object<br>Default Macerial<br>Bounce Threshold<br>Default Max Depenetration Velocity<br>Sieep Threshold<br>Default Contact Offset<br>Default Solver Iterations<br>Default Solver Velocity Rerations<br>Queries Hit Backfaces<br>Queries Hit Triggers<br>Enable Adaptive Force<br>Simulation Mode<br>Auto Sync Transforms<br>Reuse Collision Callbacks<br>Invoke Collision Callbacks<br>Contact Pairs Mode<br>Broadphase Type<br>Friction Type<br>Enable Enhanced Determinism<br>Enable Unified Heightmags<br>Improved Patch Friction<br>Salver Type<br>Default Max Angular Speed<br>Scratch Buffer Chunk Count<br>Fast Motion Threshold</td>
<td>Cloth<br>Nome (Physics Material)<br>2<br>10<br>0.005<br>0.01<br>6<br>3<br>&gt;<br>Fixed Update<br>&gt;<br>S<br>Default Contact Pairs<br>Sweep And Prune Broadphase<br>Patch Friction Type<br>S<br>Projected Gouss Seidel<br>7<br>4<br>3.402823e+38</td>
<td></td>
<td>0</td>
</tr>
</tbody>
</table>
<p>Modify the physics project settings to squeeze out more performance.</p>
<h2 id="adjust-simulation-frequency">Adjust simulation frequency</h2>
<p>Physics engines work by running on a fixed time step. To see the fixed rate that your project is running at, go to <strong>Edit</strong> &gt; <strong>Project Settings</strong> &gt; <strong>Time</strong>.</p>
<p>The <strong>Fixed Timestep</strong> field defines the time delta used by each physics step. For example, the default value of 0.02 seconds (20 ms) is equivalent to 50 fps, or 50 Hz.</p>
<table>
<thead>
<tr>
<th>Project Settings</th>
<th></th>
<th></th>
<th></th>
<th>ロ<br>×</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>* Project Settings</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Adaptive Performance</td>
<td>Time</td>
<td></td>
<td>a</td>
<td>0 2 1</td>
<td></td>
</tr>
<tr>
<td>Audio<br>Burst AOT Settings<br>Editor<br>Graphics<br>In-Editor Tutorials<br>Input Manager<br>v. Input System Package<br>Settings<br>Meimory Settings<br>Package Manager<br>v. Physics<br>Settings<br>Physics 20<br>Player<br>Preset Manager<br>· Quality<br>HORP<br>Scene Template<br>Script Execution Order<br>Services<br>ShaderGraph<br>Tags and Layers<br>TextMesh Pro<br>Time<br>Timeline<br>Ul Toolkit<br>Version Control<br>VEX<br>Visual Scripting<br>XR Plugin Management<br>0</td>
<td>Fiked Timestep<br>Maximum Allowed Timestep<br>Time Scalo<br>Maximum Particle Timestop</td>
<td>0.02<br>0.1<br>1-<br>0.03</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>The default Fixed Timestep in the Project Settings is 0.02 seconds (50 frames per second).</p>
<p>Because each frame in Unity takes a variable amount of time, it is not perfectly synced with the physics simulation. The engine counts up to the next physics time step. If a frame runs slightly slower or faster, Unity uses the elapsed time to know when to run the physics simulation at the proper time step.</p>
<p>In the event that a frame takes a long time to prepare, this can lead to performance issues. For example, if your game experiences a spike (e.g., instantiating many GameObjects or loading a file from disk), the frame could take 40 ms or more to run. With the default 20 ms Fixed Timestep, this would cause two physics simulations to run on the following frame in order to &quot;catch up&quot; with the variable time step.</p>
<p>Extra physics simulations, in turn, add more time to process the frame. On lower-end platforms, this potentially leads to a downward spiral of performance.</p>
<p>A subsequent frame taking longer to prepare makes the backlog of physics simulations longer as well. This leads to even slower frames and even more simulations to run per frame. The result is worse and worse performance.</p>
<p>Eventually the time between physics updates could exceed the Maximum Allowed Timestep. After this cutoff, Unity starts dropping physics updates, and the game stutters.</p>
<p>To avoid performance issues with physics:</p>
<p>— Reduce the simulation frequency. For lower-end platforms, increase the Fixed Timestep to slightly more than your target frame rate. For example, use 0.035 seconds for 30ps on mobile. This could help prevent that downward performance spiral.</p>
<ul>
<li><span id="page-81-0"></span>— Decrease the Maximum Allowed Timestep. Using a smaller value (like 0.1 s) sacrifices some physics simulation accuracy, but also limits how many physics updates can happen in one frame. Experiment with values to find something that works for your project&#39;s requirements.</li>
<li>Simulate the physics step manually if necessary by choosing the <a href="https://docs.unity3d.com/6000.0/Documentation/ScriptReference/SimulationMode.html">SimulationMode</a> during the Update phase of the frame. This allows you to take control when to run the physics step. Pass Time.deltaTime to Physics.Simulate in order to keep the physics in sync with the simulation time.</li>
</ul>
<p>This approach can cause instabilities in the physics simulation in scenes with complex physics or highly variable frame times, so use it with caution.</p>
<p><img src="_page_81_Figure_4.jpeg" alt=""></p>
<p>Profiling a scene in Unity with manual simulation</p>
<h2 id="modify-cookingoptions-for-meshcolliders">Modify CookingOptions for MeshColliders</h2>
<p>Meshes used in physics go through a process called cooking. This prepares the mesh so that it can work with physics queries like raycasts, contacts, and so on.</p>
<p>A MeshCollider has several <a href="https://docs.unity3d.com/6000.0/Documentation/ScriptReference/MeshColliderCookingOptions.html?">CookingOptions</a> to help you validate the mesh for physics. If you are certain that your mesh does not need these checks, you can disable them to speed up your cook time.</p>
<p>In the CookingOptions for each MeshCollider, simply uncheck the EnableMeshCleaning, WeldColocatedVertices, and CookForFasterSimulation. These options are valuable for procedurally generated meshes at runtime, but can be disabled if your meshes already have the proper triangles.</p>
<p><span id="page-82-0"></span><img src="_page_82_Picture_0.jpeg" alt=""></p>
<p>Also, if you are targeting PC, make sure you keep Use Fast Midphase enabled. This switches to a faster algorithm from PhysX 4.1 during the mid-phase of the simulation (which helps narrow down a small set of potentially intersecting triangles for physics queries).</p>
<table>
<thead>
<tr>
<th>a :<br>E Hierarchy</th>
<th></th>
<th>Inspector</th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th>ತ</th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>+ = All</td>
<td>24</td>
<td>D<br>Procedural Mesh</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>Static ▼</td>
<td></td>
<td></td>
</tr>
<tr>
<td>C MainScene<br>1<br>Main Camera<br>20</td>
<td></td>
<td>Tag Untagged</td>
<td></td>
<td>&gt;</td>
<td>Layer Default</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Virtual Camera<br>Camera Confiner</td>
<td></td>
<td>V 4<br>Transform</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>0 2</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Lighting</td>
<td></td>
<td>Position</td>
<td>× 0</td>
<td></td>
<td>Y O</td>
<td>Z<br>0</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Reflection Probe</td>
<td>&gt;</td>
<td>Rotation</td>
<td>X 0</td>
<td></td>
<td>Y 180</td>
<td>2<br>0</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Directional Light<br>NonKinematic Volume</td>
<td></td>
<td>Scale</td>
<td>×1</td>
<td></td>
<td>Y 1.</td>
<td>Z 1</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Kinematic Volume</td>
<td></td>
<td># &gt; Mesh Collider</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>0</td>
<td>24</td>
<td></td>
<td></td>
</tr>
<tr>
<td>SkyParticle<br>Managers<br>A</td>
<td></td>
<td>Convex</td>
<td>V</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Environment</td>
<td></td>
<td>Is Trigger</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Objects<br>4<br>&gt; Canvas</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Settings</td>
<td></td>
<td></td>
<td></td>
<td>Cooking Options</td>
<td>Mixed</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Queries<br>Raycast Commands</td>
<td></td>
<td>Material<br>Mesh</td>
<td></td>
<td>None</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>0<br>0</td>
<td></td>
</tr>
<tr>
<td>Procedural Mesh</td>
<td></td>
<td></td>
<td></td>
<td>Everything</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td>J J Mesh Renderer</td>
<td>&gt;</td>
<td></td>
<td>Cook For Faster Simulation</td>
<td></td>
<td></td>
<td>14</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td>Materials</td>
<td>V</td>
<td></td>
<td>Enable Mesh Cleaning</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td>Element O</td>
<td>&gt;</td>
<td></td>
<td>Weld Colocated Vertices</td>
<td></td>
<td></td>
<td>0</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td>V</td>
<td>Use Fast Midphase</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td>T Lighting</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td>Cast Shadows</td>
<td>On</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>Contribute Global Illumination</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td>Receive Global Illumination<br>T Probes</td>
<td></td>
<td>Light Probes</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>Cooking options for a mesh</p>
<h2 id="use-physics-bakemesh">Use Physics.BakeMesh</h2>
<p>If you are generating meshes procedurally during gameplay, you can create a Mesh Collider at runtime. Adding a MeshCollider component directly to the mesh, however, cooks/bakes the physics on the main thread. This can consume significant CPU time.</p>
<p>Use <a href="https://docs.unity3d.com/6000.0/Documentation/ScriptReference/Physics.BakeMesh.html">Physics.BakeMesh</a> to prepare a mesh for use with a MeshCollider and save the baked data with the mesh itself. A new MeshCollider referencing this mesh will reuse this prebaked data (rather than baking the mesh again). This can help reduce Scene load time or instantiation time later.</p>
<p>To optimize performance, you can offload mesh cooking to another thread with the <a href="https://docs.unity3d.com/6000.0/Documentation/Manual/JobSystemOverview.html">C# job</a>  <a href="https://docs.unity3d.com/6000.0/Documentation/Manual/JobSystemOverview.html">system</a>. Refer to <a href="https://docs.unity3d.com/6000.0/Documentation/ScriptReference/Physics.BakeMesh.html">this example</a> for details on how to bake meshes across multiple threads.</p>
<p><span id="page-83-0"></span></p>
<table>
<thead>
<tr>
<th>(5) (2)</th>
<th>II 83 ×<br>Pivot BLocal<br>ਜਾ</th>
<th></th>
<th>=<br>DI</th>
</tr>
</thead>
<tbody>
<tr>
<td>Package Manager</td>
<td>Frame Debug Project Settings Animator<br># Scene</td>
<td>Physics Debug Preferences<br>Profiler</td>
<td></td>
</tr>
<tr>
<td>Profiler Modules</td>
<td>· Playmode · (2) 14 N Frame: 275 / 275<br>Clear</td>
<td>Clear on Play Deep Profile Call Stacks ▼</td>
<td>H</td>
</tr>
<tr>
<td>ജ, CPU Usage<br>· Rendering<br>Scripts<br>· Physics<br>· Animation<br>GarbageCollector<br>· VSync<br>Global Illumination<br>UI<br>Others</td>
<td>33ms (30FPS)<br>16ms (60FPS)</td>
<td></td>
<td>Selected: BakeMeshJob (Burst)</td>
</tr>
<tr>
<td>2 Rendering<br>Batches Count</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Timeline</td>
<td>· Live</td>
<td>CPU:11.02ms GPU :- - ms</td>
<td></td>
</tr>
<tr>
<td></td>
<td>15ms<br>11<br>thysX CollisionD</td>
<td>1 10ms<br>ext. Submit<br>er Single Ca</td>
<td>A - Resident</td>
</tr>
<tr>
<td>Render Thread</td>
<td>r Gfx Commands From Main Threa<br>maphore.WaitForSignal (2.78m</td>
<td>Ir Single Ca<br>cute: For<br>9</td>
<td></td>
</tr>
<tr>
<td>Job</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Worker 0</td>
<td>Idle (1,71ms)<br>(2.50ms)<br>b (Bur</td>
<td>Idle (3.7 Ims)<br>Idle (1.83ms)<br>Idle (1.33ms)</td>
<td></td>
</tr>
<tr>
<td>Worker 1</td>
<td>BakeMeshJob (Burst)<br>   clie (2.59ms)<br>Idle (1.71ms)<br>0.562ms</td>
<td>Idie (3.10ms)<br>12)</td>
</tr>
</tbody>
</table>
<p>BakeMeshJob in the Profiler</p>
<h2 id="use-box-pruning-for-large-scenes">Use Box Pruning for large scenes</h2>
<p>The Unity physics engine runs in two steps:</p>
<ul>
<li>The <strong>broad phase</strong>, which collects potential collisions using a <a href="https://en.wikipedia.org/wiki/Sweep_and_prune">sweep and prune</a> algorithm</li>
<li>The narrow phase, where the engine actually computes the collisions</li>
</ul>
<p>The broad phase default setting of Sweep and Prune BroadPhase (<strong>Edit &gt; Project Settings &gt; Physics &gt; BroadPhase Type</strong>) can generate false positives for worlds that are generally flat and have many colliders.</p>
<p>If your scene is large and mostly flat, avoid this issue and switch to <strong>Automatic Box Pruning</strong> or <strong>Multibox Pruning Broadphase</strong>. These options divide the world into a grid, where each grid cell performs sweep-and-prune.</p>
<p>Multibox Pruning Broadphase allows you to specify the world boundaries and the number of grid cells manually, while Automatic Box Pruning calculates that for you.</p>
<p><span id="page-84-0"></span></p>
<table>
<thead>
<tr>
<th>Project Settings<br>Or Froject Seltings</th>
<th></th>
<th>0<br>×<br>4</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>Adaptive Performance<br>Audio<br>Burst ACT Settings<br>Ecitor<br>Graphics<br>In-Editor Tutorials<br>Input Manager<br>r. Input System Package<br>Settings<br>Memory Settings<br>Package Manager<br>v Physics<br>Settings<br>Plysics ZD<br>Player<br>Proset Manager<br>v Quality<br>HORP<br>Scene Template<br>Script Execution Order<br>Services<br>ShaderGraph<br>Togs and Leyers<br>TextMesh Pro<br>Time<br>Timeine<br>Ul Toolkit<br>Version Control<br>VIX<br>Visual Seripting<br>XR Plagin Management</td>
<td>Physics Settings<br>Shared Came Object<br>Cloch<br>Default Material<br>None (Physics Material)<br>Bounce Threshold<br>2<br>Default Max Depenetration Velocity<br>10<br>0.005<br>Sleep Threshold<br>CON<br>Dofault Contact Officet<br>Default Sover Iterations<br>6<br>Dofsult Golver Velocity Items<br>1<br>Queries Hit Backfaces<br>Queries Hit Triggers<br>S<br>Eneble Adaptive Force<br>Simulation Mode<br>Fixed Update<br>Auto Sync Transforms<br>Rieuse Colliston Califorcous<br>S<br>Invoke Collsion Calibacks<br>S<br>Contact Pairs Mode<br>Default Contact Pairs<br>Broadphase Type<br>Sweep And Prune Broadphase.<br>Friction Type<br>Sycep And Frune Broadphase<br>Enable Enhanced Determinism<br>Automatic Box Pruning<br>Enable Unified Heightmaps<br>Improved Patch Friction<br>Solver Type<br>Projected Gauns Seidel<br>Default Max Angular Speed<br>23<br>Scretch Buffer Churk Count<br>4<br>2402022e-30<br>Fast Motion Threahold</td>
<td>0</td>
</tr>
</tbody>
</table>
<p>Broadphase Type in the Physics options</p>
<h2 id="modify-solver-iterations">Modify solver iterations</h2>
<p>If you want to simulate a specific physics body more accurately, increase its <a href="https://docs.unity3d.com/6000.0/Documentation/ScriptReference/Rigidbody-solverIterations.html?">Rigidbody.</a> <a href="https://docs.unity3d.com/6000.0/Documentation/ScriptReference/Rigidbody-solverIterations.html?">solverIterations.</a></p>
<table>
<thead>
<tr>
<th>FOR CONSULT REPORT OF OFFICE ENTER OFFICE OF CONSTITUENTIAL OF C</th>
<th>8000<br>Project Settings<br>C Project Sectings<br>Adaptive Performance<br>Asdio<br>Qurst AOT Gettings<br>Editor<br>Graphics<br>in-Editor Tutorials<br>Input Masager<br>Input System Package<br>Seelings<br>Memory Settings<br>Package Manager<br>Physics<br>Sectings<br>Physics 20<br>Player<br>Preset Manager<br>Quality<br>Scene Template<br>Script Execution Orger<br>Services<br>ShederGraph<br>Tags and Layers<br>TastMosh Pro<br>Time<br>Timeine<br>UR Tocilist<br>Version Control<br>VEX<br>KR Plugin Marageness</th>
<th>Physics Settings<br>Shared Game Colect<br>Default Material<br>Bounce Threshold-<br>Default Max Depenetration Welecity 10<br>Sleep Throshold<br>Default Contact Officer<br>Default Solver Iterations<br>Detault Solver Veiocity Itarations<br>Queries Hit Backfaces<br>Queries Hit Triggers<br>Eneble Adeptive Force:<br>Simulation Mode<br>Auto Sysc Transforms<br>Reuse Collision Calibacks<br>Involve Collision Callbecks<br>Contact Pairs Mode<br>Broadphase Type<br>Friction Type<br>Enable Erhanced Detectinium.<br>Enable Unitied Heightmags<br>Improved Patch Friction<br>Sofier Type<br>Default Max Angular Speed<br>Scrafch Buffer Churk Count<br>Fast Motion Threshold</th>
<th>NEWS BEELER<br>4<br>Cloth<br>Niana (Physics Material)<br>26<br>0.005<br>0.01<br>6<br>10<br>&gt;<br>Fined Update<br>8<br>Default Contact Pars<br>Swoop And Prune Breadphase<br>Patch Friction Type<br>V<br>Projected Gauss Seicel<br>77<br>4<br>3.402823e+38</th>
<th>0 ×<br>@</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>ﻥ<br>10</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>Override the Default Solver Iterations per <a href="https://unity.com/products/cloud-content-delivery">Rigidbody</a>.</p>
<p><span id="page-85-0"></span><img src="_page_85_Picture_0.jpeg" alt=""></p>
<p>This overrides the Physics.defaultSolverIterations, which can also be found in <strong>Edit</strong> &gt; <strong>Project Settings</strong> &gt; <strong>Physics</strong> &gt; <strong>Default Solver Iterations</strong>.</p>
<p>To optimize your physics simulations, set a relatively low value in the project&#39;s defaultSolveIterations. Then apply higher custom Rigidbody.solverIterations values to the individual instances that need more detail.</p>
<h2 id="disable-automatic-transform-syncing">Disable automatic transform syncing</h2>
<p>By default, Unity does not automatically synchronize changes to Transforms with the physics engine. Instead, it waits until the next physics update or until you manually call <a href="https://docs.unity3d.com/6000.0/Documentation/ScriptReference/Physics.SyncTransforms.html">Physics.</a> <a href="https://docs.unity3d.com/6000.0/Documentation/ScriptReference/Physics.SyncTransforms.html">SyncTransforms</a>. When this is enabled, any <a href="https://docs.unity3d.com/6000.0/Documentation/ScriptReference/Rigidbody.html?">Rigidbody</a> or <a href="https://docs.unity3d.com/6000.0/Documentation/ScriptReference/Collider.html?">Collider</a> on that <a href="https://docs.unity3d.com/6000.0/Documentation/ScriptReference/Transform.html?">Transform</a> or its children automatically sync with the physics engine.</p>
<h4 id="-when-to-manually-sync-"><strong>When to manually sync</strong></h4>
<p>When autoSyncTransforms is disabled, Unity only synchronizes transformations before the physics simulation step in FixedUpdate or when explicitly requested through Physics.Simulate. You might need to perform additional syncs if you use APIs that read directly from the physics engine between Transform changes and the physics update. Examples include accessing <strong>Rigidbody.position</strong> or performing <strong>Physics.Raycast</strong>.</p>
<h4 id="-performance-best-practice-"><strong>Performance best practice</strong></h4>
<p>Although autoSyncTransforms ensures up-to-date physics queries, it incurs a performance cost. Each physics-related API call forces a sync, which can degrade performance, especially with multiple successive queries. Follow these best practices:</p>
<ul>
<li><strong>— Disable autoSyncTransforms unless necessary</strong>: Only enable it if precise, continuous syncing is crucial for your game mechanics.</li>
<li><strong>— Use manual syncing</strong>: For better performance, manually synchronize Transforms with Physics.SyncTransforms() before calls that require the latest Transform data. This approach is more efficient than enabling autoSyncTransforms globally.</li>
</ul>
<p><span id="page-86-0"></span><img src="_page_86_Picture_1.jpeg" alt=""></p>
<p>Profiling a scene in Unity with Auto Sync Transform disabled</p>
<h2 id="use-contact-arrays">Use Contact Arrays</h2>
<p><a href="https://docs.unity3d.com/6000.0/Documentation/ScriptReference/Physics.ContactEvent.html">Contact Arrays</a> gives you a method where collision data (contacts) is stored and managed in an array format. This means that every collision event generates an array of contact points, which can be accessed and processed. Being an array it provides a contiguous block of memory, which speeds up access times when processing collision data and sets it up for batch processing and can be combined with the C# Job System in performance-critical use cases.</p>
<h2 id="reuse-collision-callbacks">Reuse Collision Callbacks</h2>
<p>Contact arrays are generally significantly faster and so the general recommendation is to use those rather than reusing collision callbacks, however consider the following if you do have a specific use case for it.</p>
<p>The callbacks <a href="https://docs.unity3d.com/6000.0/Documentation/ScriptReference/MonoBehaviour.OnCollisionEnter.html">MonoBehaviour.OnCollisionEnter</a>, <a href="https://docs.unity3d.com/6000.0/Documentation/ScriptReference/MonoBehaviour.OnCollisionStay.html?">MonoBehaviour.OnCollisionStay</a> and <a href="https://docs.unity3d.com/6000.0/Documentation/ScriptReference/MonoBehaviour.OnCollisionExit.html?">MonoBehaviour.OnCollisionExit</a> all take a collision instance as a parameter. This collision instance is allocated on the managed heap and must be garbage collected.</p>
<p>To reduce the amount of garbage generated, enable <a href="https://docs.unity3d.com/6000.0/Documentation/ScriptReference/Physics-reuseCollisionCallbacks.html?">Physics.reuseCollisionCallbacks</a> (also found in <strong>Projects Settings &gt; Physics &gt; Reuse Collision Callbacks</strong>). With this active, Unity only assigns a single collision pair instance to each callback. This reduces waste for the garbage</p>
<p><span id="page-87-0"></span><img src="_page_87_Picture_0.jpeg" alt=""></p>
<p>collector and improves performance.</p>
<p>The general recommendation is to always enable Reuse Collision Callbacks for performance benefits. You should only disable this feature for legacy projects where the code relies on individual Collision class instances, making it impractical to store individual fields.</p>
<p><img src="_page_87_Picture_3.jpeg" alt=""></p>
<p>In the Unity Console, there is a single collision instance on Collision Entered and Collision Stay.</p>
<h2 id="move-static-colliders">Move static colliders</h2>
<p>Static colliders are GameObjects with a Collider component but without a Rigidbody.</p>
<p>Note that you can move a static collider, contrary to the term &quot;static.&quot; To do so, simply modify the position of the physics body. Accumulate the positional changes and sync before the physics update. You don&#39;t need to add a Rigidbody component to the static collider just to move it.</p>
<p>However, if you want the static collider to interact with other physics bodies in a more complex way, give it a <a href="https://docs.unity3d.com/6000.0/Documentation/ScriptReference/Rigidbody-isKinematic.html?">kinematic Rigidbody</a>. Use <a href="https://docs.unity3d.com/6000.0/Documentation/ScriptReference/Rigidbody-position.html?">Rigidbody.position</a> and <a href="https://docs.unity3d.com/6000.0/Documentation/ScriptReference/Rigidbody-rotation.html?">Rigidbody.rotation</a> to move it instead of accessing the Transform component. This guarantees more predictable behavior from the physics engine.</p>
<p><strong>Note:</strong> If an individual Static Collider 2D needs to be moved or reconfigured at runtime, then add a Rigidbody 2D component and set it to the <strong>Static</strong> Body Type, as it is faster to simulate the Collider 2D when it has its own Rigidbody 2D. If a group of Collider 2Ds needs to be moved or reconfigured at runtime, it is faster to have them all be children of the single hidden parent Rigidbody 2D than to move each GameObject individually.</p>
<h2 id="-span-id-page-88-0-span-use-non-allocating-queries"><span id="page-88-0"></span>Use non-allocating queries</h2>
<p>To detect and collect colliders in 3D projects within a certain distance and in a certain direction, use raycasts and other physics queries like <a href="https://docs.unity3d.com/6000.0/Documentation/ScriptReference/Physics.BoxCast.html">BoxCast</a>. Note that</p>
<p>Physics queries that return multiple colliders as an array, like <a href="https://docs.unity3d.com/6000.0/Documentation/ScriptReference/Physics.OverlapSphere.html">OverlapSphere</a> or <a href="https://docs.unity3d.com/6000.0/Documentation/ScriptReference/Physics.OverlapBox.html">OverlapBox</a>, need to allocate those objects on the managed heap. This means that the garbage collector eventually needs to collect the allocated objects, which can decrease performance if it happens at the wrong time.</p>
<p>To reduce this overhead, use the <strong>NonAlloc</strong> versions of those queries. For example, if you are using OverlapSphere to collect all potential colliders around a point, use <a href="https://docs.unity3d.com/6000.0/Documentation/ScriptReference/Physics.OverlapSphereNonAlloc.html">OverlapSphereNonAlloc</a> instead.</p>
<p>This allows you to pass in an array of colliders (the results parameter) to act as a buffer. The NonAlloc method works without generating garbage. Otherwise, it functions like the corresponding allocating method.</p>
<p>Note that you need to define a results buffer of sufficient size when using a NonAlloc method. The buffer does not grow if it runs out of space.</p>
<h4 id="-2d-physics-"><strong>2D Physics</strong></h4>
<p>Note that the above advice does not apply to 2D physics queries, because in Unity&#39;s 2D physics system, methods do not have a &quot;NonAlloc&quot; suffix. Instead, all 2D physics methods, including those that return multiple results, provide overloads that accept arrays or lists. For instance, while the 3D physics system has methods like RaycastNonAlloc, the 2D equivalent simply uses an overloaded version of Raycast that can take an array or List<T> as a parameter, such as:</p>
<p><img src="_page_88_Picture_9.jpeg" alt=""></p>
<p>By using overloads, you can perform non-allocating queries in the 2D physics system without needing specialized NonAlloc methods.</p>
<h2 id="batch-queries-for-ray-casting">Batch queries for ray casting</h2>
<p>You can run raycast queries with <a href="https://docs.unity3d.com/6000.0/Documentation/ScriptReference/Physics.Raycast.html?">Physics.Raycast</a>. However, if you have a large number of raycast operations (e.g., calculating line of sight for 10,000 agents), this may take a significant amount of CPU time.</p>
<p>Use <a href="https://docs.unity3d.com/6000.0/Documentation/ScriptReference/RaycastCommand.html?">RaycastCommand</a> to batch the query using the C# Job System. This offloads the work from the main thread so that the raycasts can happen asynchronously and in parallel.</p>
<p>See a usage example at the <a href="https://docs.unity3d.com/6000.0/Documentation/ScriptReference/RaycastCommand.html?">RaycastCommands</a> documentation page.</p>
<h2 id="-span-id-page-89-0-span-visualize-with-the-physics-debugger"><span id="page-89-0"></span>Visualize with the Physics Debugger</h2>
<p>Use the Physics Debug window (<strong>Window &gt; Analysis &gt; Physics Debugger</strong>) to help troubleshoot any problem colliders or discrepancies. This shows a color-coded indicator of the GameObjects that can collide with one another.</p>
<p><img src="_page_89_Picture_3.jpeg" alt=""></p>
<p>The Physics Debugger helps you visualize how your physics objects can interact with one another.</p>
<p>For more information, see <a href="https://docs.unity3d.com/6000.0/Documentation/Manual/PhysicsDebugVisualization.html">Physics Debugger documentation</a>.</p>
<h2 id="workflow-and-collaboration">Workflow and collaboration</h2>
<h4 id="-why-use-version-control-"><strong>Why use version control?</strong></h4>
<p>Building an application in Unity is a demanding endeavor that often involves many developers. Make sure that your project is set up optimally for your team to collaborate.</p>
<p>A version control system (VCS) allows you to keep a historical record of your entire project. It brings organization to your work and enables teams to iterate efficiently.</p>
<p>Project files are stored in a shared database called a repository, or &quot;repo.&quot; You backup your project at regular intervals to the repo, and if something goes wrong, you can revert back to an earlier version of the project.</p>
<p>With a VCS, you can make multiple individual changes and commit them as a single group for versioning. This commit sits as a point on the timeline of your project, so that if you need to revert back to a previous version, everything from that commit is undone and restored to the state it was at the time. You can review and modify each change grouped within a commit or undo the commit entirely.</p>
<p><span id="page-90-0"></span><img src="_page_90_Picture_0.jpeg" alt=""></p>
<p>With access to the project&#39;s entire history, it&#39;s easier to identify which changes introduced bugs, restore previously removed features, and easily document changes between your game or product releases.</p>
<p>What&#39;s more, because version control is typically stored in the cloud or on a distributed server, it supports your development team&#39;s collaboration from wherever they&#39;re working – an increasingly important benefit as remote work becomes commonplace.</p>
<h4 id="-unity-version-control-"><strong>Unity Version Control</strong></h4>
<p><a href="https://docs.unity.com/ugs/en-us/manual/devops/manual/unity-version-control">Unity Version Control</a> (UVCS) is a flexible version control system with unique interfaces to support programmers and artists alike. It excels at handling large repos and binary files, and as both a file-based and changeset-based solution, it gives you the capability to download only the specific files you&#39;re working on, rather than the entire project build.</p>
<p>There are three ways to access UVCS: via multiple applications and repositories through the UVCS <a href="https://docs.unity.com/ugs/en-us/manual/devops/manual/version-control-desktop-client">desktop client</a>, by adding it to your projects <a href="https://learn.unity.com/tutorial/how-to-use-the-unity-hub?courseId=6401bbfcedbc2a22aaebd59b">through the Unity Hub,</a> or accessing the repository on Unity cloud via your web browser.</p>
<p>UVCS allows you to:</p>
<ul>
<li>Work knowing that your art assets are securely backed up.</li>
<li>Track ownership of every asset.</li>
<li>Roll back to previous iterations of an asset.</li>
<li>Drive automated processes on a single central repository.</li>
<li>Create branches quickly and securely over multiple platforms.</li>
</ul>
<p>Additionally, UVCS helps you centralize your development with excellent visualization tools. Artists especially will appreciate the user-friendly workflows that encourage tighter integration between development and art teams with <a href="https://docs.plasticscm.com/gluon/plastic-scm-version-control-gluon-guide">the Gluon application,</a> which makes it easier to see and manage just the files they need without dealing with the entire project repository complexity. Besides offering a simplified workflow it also offers tooling that makes it easy to see visual differences in asset versions and easier to contribute to a unified version control environment.</p>
<p>To help with version control merges, make sure your <strong>Editor Settings</strong> have <strong>Asset Serialization Mode</strong> set to <strong>Force Text</strong>.</p>
<p><img src="_page_90_Picture_15.jpeg" alt=""></p>
<p><span id="page-91-0"></span><img src="_page_91_Picture_0.jpeg" alt=""></p>
<p>If you&#39;re using an external version control system (such as Git) in the <strong>Version Control</strong> settings, verify that the <strong>Mode</strong> is set to <strong>Visible Meta Files</strong>.</p>
<table>
<thead>
<tr>
<th>Version Control</th>
<th></th>
<th>14</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>Mode</td>
<td>Visible Meta Files</td>
<td></td>
<td>&gt;</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>Unity also has a built-in YAML (a human-readable, data-serialization language) tool specifically used for merging scenes and prefabs. For more information, see <a href="https://docs.unity3d.com/6000.0/Documentation/Manual/SmartMerge.html?">Smart Merge</a> in the Unity documentation.</p>
<p>Learn more about Unity VCS, and general version control and project organization best practices, in the e-book <em>Version control and project organization best practices for game developers</em>.</p>
<h4 id="-break-up-large-scenes-"><strong>Break up large scenes</strong></h4>
<p>Large, single Unity scenes do not lend themselves well to collaboration. Divide your levels into multiple smaller scenes so artists and designers can collaborate effectively on a single level while minimizing the risk of conflicts.</p>
<p>Note that, at runtime, your project can load scenes additively using <strong>SceneManager. LoadSceneAsync</strong> passing the <strong>LoadSceneMode.Additive</strong> parameter mode.</p>
<h4 id="-remove-unused-resources-"><strong>Remove unused resources</strong></h4>
<p>Watch out for any unused assets that come bundled with third-party plug-ins and libraries. Many include embedded test assets and scripts, which will become part of your build if you don&#39;t remove them. Strip out any unneeded resources left over from prototyping.</p>
<p>All of the optimization tips demonstrated in this e-book will benefit your game regardless of your platform. This next section focuses on specific optimization tips for XR and web.</p>
<h2 id="platform-specific-tips-for-unity-web-builds">Platform-specific tips for Unity Web Builds</h2>
<p>Optimizing Unity Web builds requires a unique approach due to the inherent limitations and challenges of running applications within a web browser. Web builds must balance performance, load times, and compatibility across a wide range of devices and browsers. In this section, we&#39;ll explore key strategies and best practices specifically tailored to Unity Web projects. From asset management and memory optimization to reducing build size and enhancing user experience, these tips will help you create high-performance web applications that deliver seamless experiences across different environments.</p>
<p><span id="page-92-0"></span><img src="_page_92_Picture_0.jpeg" alt=""></p>
<h4 id="-framerate-"><strong>Framerate</strong></h4>
<ul>
<li><strong>—</strong> Keep <strong>Application.targetFrameRate</strong> at the default project setting value of -1 for Unity Web builds. Keeping targetFrameRate to -1 instructs the browser to tie frame rate to the browser&#39;s &quot;animation rate&quot;, i.e., it provides you with the fastest possible rendering rate, which is typically the same as the native refresh rate of the display, at least in the case of Firefox and Chrome. However, in Safari, the refresh rate is always capped at 60 fps.</li>
<li>If you have changed default settings in your project, you can also create a new C# script or open an existing script where you want to set the target frame rate. Typically, this would be in a script that initializes your game or in a central game manager script.</li>
</ul>
<p><img src="_page_92_Figure_5.jpeg" alt=""></p>
<h2 id="publishing-settings-for-unity-web">Publishing settings for Unity Web</h2>
<h4 id="-compression-"><strong>Compression</strong></h4>
<p>Compression significantly reduces the size of the files that need to be downloaded by the user&#39;s browser. Smaller files result in a smaller, faster download which also consumes less bandwidth.</p>
<p>The following compression methods are available.</p>
<p><strong>Brotli</strong>: Provides a higher compression ratio compared to gzip, resulting in smaller file sizes and faster load times; supported by modern browsers, and requires a web site to be served from a secure https:// URL or from a <a href="http://localhost/">http://localhost</a>/ testing URL</p>
<p><strong>Gzip</strong>: Widely supported and still effective; use this option if content is being served over an insecure http:// server, hosted on a web server that has not yet been configured to serve Brotli-compressed content, or if you&#39;re using more complex CDN load balancing or caching infrastructure that are not yet compatible with Brotli</p>
<p><strong>Uncompressed</strong>: Generally not recommended for production due to the significantly larger file sizes and slower load times; deploy with this setting only if the web server has been only configured to use an on-the-fly compression cache and does not support pre-compressed Brotli or Gzip content.</p>
<p><span id="page-93-0"></span><img src="_page_93_Picture_0.jpeg" alt=""></p>
<p>Brotli is generally the best compression method when publishing a Unity Web build due to its high compression ratio, browser support and performance.</p>
<table>
<thead>
<tr>
<th>@ Inspector &amp; Project Settings</th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>a</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Adaptive Performance<br>D<br>Simulator</td>
<td></td>
<td>Player</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>0 2</td>
<td></td>
</tr>
<tr>
<td>Audio<br>Burst AOT Settings<br>Editor<br>Graphics</td>
<td></td>
<td>Company Name<br>Product Name<br>Version</td>
<td>DefaultCompany<br>WEBGLeBook<br>0.1</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>In-Editor Tutorials<br>Input Manager<br>v Input System Package<br>Settings<br>Memory Settings<br>Package Manager<br>Physics<br>Physics 20</td>
<td></td>
<td>Default Icon</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>None<br>(Texture 20)</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td>Default Cursor</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>Select<br>None<br>(Texture 20)<br>Select</td>
<td></td>
</tr>
<tr>
<td>Player<br>Preset Manager</td>
<td></td>
<td>Cursor Hotspot</td>
<td>X 0</td>
<td></td>
<td>Y 0</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Quality</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Scene Template<br>Script Execution Order</td>
<td></td>
<td>G</td>
<td>100</td>
<td>es</td>
<td></td>
<td>0</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Services</td>
<td></td>
<td>Settings for Web</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>ShaderGraph</td>
<td></td>
<td>&gt; Icon</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Tags and Layers<br>TextMesh Pro</td>
<td></td>
<td>Resolution and Presentation</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Time<br>Timeline</td>
<td></td>
<td>Splash Image</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Ul Toolkit<br>Version Control</td>
<td></td>
<td>&gt; Other Settings</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>VFX<br>XR Plug-in Management<br>OpenXR<br>Project Validation<br>XR Interaction Toolkit</td>
<td></td>
<td>Publishing Settings<br>Compression Format<br>Name Files As Hashes<br>Data Caching<br>Debug Symbols<br>Show Diagnostics Overlay<br>Decompression Fallback<br>Power Preference</td>
<td>Brotli<br>&gt;<br>Brotli<br>Gzip<br>Disabled<br>100<br>High Performance</td>
<td></td>
<td></td>
<td></td>
<td>œ<br>&gt;</td>
</tr>
</tbody>
</table>
<p>Selecting Brotli within the publishing settings</p>
<p>It&#39;s recommended that the <strong>Decompression Fallback</strong> setting is set to <strong>Disabled</strong> to ensure fast site startup times; additionally, the web server that is hosting the page should be configured to serve pre-compressed Unity content.</p>
<p>Having Decompression Fallback enabled is harmful for battery usage for mobile browsers, and slows down game startup times. Follow the web server configuration guidelines <a href="https://docs.unity3d.com/Manual/webgl-server-configuration-code-samples.html">on this</a>  <a href="https://docs.unity3d.com/Manual/webgl-server-configuration-code-samples.html">documentation page</a>.</p>
<h4 id="-strip-engine-code-"><strong>Strip engine code</strong></h4>
<p>Another setting to check within the player settings is the <strong>Enable Strip Engine Code</strong> in the <strong>Player settings &gt; Other Settings</strong> panel, to ensure an efficient build.</p>
<p><span id="page-94-0"></span><img src="_page_94_Picture_0.jpeg" alt=""></p>
<table>
<thead>
<tr>
<th>@ Project Secings<br>Project Jettings</th>
<th></th>
<th>+ 0 ×<br>4</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>Adaptive Parlormance<br>Simulator<br>Audio<br>Barst AOT Settings<br>Editor.<br>Graphice<br>In-Editor Tutorials<br>Input Manager<br>Input System Package<br>Settings<br>Marricey Settings</td>
<td>Player<br>Namp Looded Uneders Alver&quot;<br>Shader Variant Loading Settings<br>Defeult chunk size (MS) <em><br>Default chank count</em><br>Overtide<br>Script Complation<br>Gorloting Oveline Gymbols<br>List Is Emply</td>
<td>021<br>C<br>93<br>P</td>
<td></td>
</tr>
<tr>
<td>Package Manager<br>Physics<br>Settings<br>Physios 20<br>Player<br>Preset Manager<br>Quality</td>
<td>Additional Complier Arguments<br>List in Grepty</td>
<td>+ --<br>Copy Darles   Illevert Apply<br>+ - 1</td>
<td></td>
</tr>
<tr>
<td>Scene Tomplate<br>Garlpt Execution Order<br>Services<br>ShaderGrioh<br>Tags and Leyers<br>TextMesh Pro<br>Time -<br>Timeline<br>U. Tookit</td>
<td>Suppress Common Warrings<br>Allew wheatly Code<br>Use Detaminlatic Compliation<br>Optimization<br>Prebake Collison Minshers®<br>· Preforided Assels®</td>
<td>Rovert Japon<br>2<br>디<br>D<br>13</td>
<td></td>
</tr>
<tr>
<td>Version Control<br>VFX<br>XR Plug-in Management<br>Openice<br>Project Valcution<br>XR Isterschen Toolers</td>
<td>Grip Engine Code&quot;<br>Managed Stripping Leval<br>Vertex Compression®<br>Occhildre Mirish Olica&quot;<br>Tecture Migmap Stripping&quot;.</td>
<td>D<br>Miriletal<br>Normal, Tangeri, Tex Coord O. Tex Coord 2, Tex Coord 3<br>ប<br>D</td>
<td></td>
</tr>
<tr>
<td></td>
<td>Stack Trace&quot;<br>Log Type<br>Crior<br>Asset<br>Warring<br>Lag<br>Exception</td>
<td>None<br>Soforony Full<br>전<br>2<br>网<br>n<br>D<br>ri<br>전<br>a ge<br>고<br>B<br>n<br>E<br>17</td>
<td></td>
</tr>
<tr>
<td></td>
<td>Logacy<br>Clarkp ElendShapes (Depecated)*<br>· Shared setting between multiple platforms.<br>- Publishing Sectings</td>
<td>0</td>
</tr>
</tbody>
</table>
<p>Enable Strip Engine Code</p>
<p>Enabling Strip Engine Code is a recommended practice to ensure an efficient build, particularly for Unity Web projects. This feature removes unused engine code, which can significantly reduce the size of the final build, leading to faster load times and better performance.</p>
<h4 id="-choose-none-in-the-enable-exceptions-setting-"><strong>Choose &quot;None&quot; in the Enable Exceptions setting</strong></h4>
<p>Exception handling requires additional code to be included in the build. By disabling exceptions, you reduce the runtime checks and exception handling code. If your project does not use exception handling as control flow, but all exceptions can be treated to terminate execution, then disabling exception handling support can result in code size savings.</p>
<p>Alternatively, if your application does require exception handling support, consider enabling WebAssembly 2023, as it optimizes the code size for exception handling in general.</p>
<p>In the <strong>Player Settings</strong> window under the Unity Web Build tab, expand <strong>Publishing Settings</strong>, and set <strong>Enable Exceptions</strong> to <strong>None</strong> if you don&#39;t need exceptions in your build.</p>
<p>Setting Enable Exceptions to none</p>
<p><span id="page-95-0"></span><img src="_page_95_Picture_0.jpeg" alt=""></p>
<h4 id="-target-webassembly-2023-feature-set-"><strong>Target WebAssembly 2023 feature set</strong></h4>
<p>If your game can afford to target Firefox &gt;= 89, Chrome &gt;= 91 and Safari &gt;= 16.4, enable the WebAssembly 2023 feature set to shrink down code size.</p>
<p>WebAssembly 2023 enables JS BigInt, Bulk Memory Operations, Non-trapping float-toint conversions, Sign-extension Operators and Fixed-width SIMD. See the WebAssembly Roadmap page to examine which browser versions support which WebAssembly features: <a href="https://webassembly.org/features/">https://webassembly.org/features/</a>.</p>
<h4 id="-code-optimization-settings-"><strong>Code Optimization settings</strong></h4>
<p>Set Code Optimization:Disk Size with LTO in Project Build Platform Settings for final release builds (LTO builds can take a very long time to produce), or Code Optimization: Disk Size for code size optimized builds when still developing.</p>
<h2 id="profiling-unity-web-builds">Profiling Unity Web Builds</h2>
<p>In addition to using Unity&#39;s <a href="#page-10-1">suite of profiling tools</a>, you can leverage tools like Chrome DevTools and <a href="https://profiler.firefox.com/">Firefox Profiler</a> to profile and analyze performance.</p>
<h4 id="-chrome-devtools-"><strong>Chrome DevTools</strong></h4>
<p>Chrome DevTools is a comprehensive set of web development tools built into the Google Chrome browser. It offers features for profiling performance, debugging JavaScript, analyzing network activity, and inspecting rendering. Here are the basic steps for activating Chrome DevTools:</p>
<ul>
<li><ol>
<li>Press F12 or <strong>Ctrl+Shift+I</strong> (Windows/Linux) or <strong>Cmd+Option+I</strong> (Mac) to open Chrome DevTools. You can also right-click on the page and select <strong>Inspect</strong>.</li>
</ol>
</li>
<li><ol>
<li>Go to the <strong>Performance</strong> tab. Click the <strong>Record</strong> button and interact with your Unity Web game to capture performance data. Click <strong>Stop</strong> to end the recording and analyze the captured data, focusing on frame rate, CPU usage, and rendering performance.</li>
</ol>
</li>
<li><ol>
<li>Navigate to the <strong>Network</strong> tab and reload your Unity Web game to capture all network requests. Examine the timeline, request details, and loading times to identify any network-related performance bottlenecks.</li>
</ol>
</li>
<li><ol>
<li>Use the <strong>Sources</strong> tab to set breakpoints in your JavaScript code to pause execution and inspect variables. Use the call stack and scope information to debug and optimize your code.</li>
</ol>
</li>
<li><ol>
<li>Use the <strong>Console</strong> tab to log Unity Web states and debug rendering issues. Utilize Unity Web-specific tools and extensions, such as Unity Web Insight or Unity Web Debugging for deeper analysis.</li>
</ol>
</li>
</ul>
<h1 id="-span-id-page-96-0-span-xr-optimization-tips"><span id="page-96-0"></span>XR optimization tips</h1>
<p>This section covers optimization tips for VR, AR, and MR applications built with Unity (collectively known as XR). Many of these techniques are mentioned in other parts of this guide because they apply to mobile devices generally but they&#39;re collected here as well for readers focusing exclusively on XR apps.</p>
<p>Try these techniques to help your XR applications run efficiently, particularly for VR, as these experiences demand high performance and low latency to maintain immersion and prevent motion sickness. High-resolution, 3D-rendered environments and responsive interactions require optimization to ensure smooth experiences that are also physically comfortable.</p>
<p>For a comprehensive guide on developing XR apps in Unity, download the e-book <em><a href="https://unity.com/resources/create-virtual-mixed-reality-experiences-unity">Create</a>  <a href="https://unity.com/resources/create-virtual-mixed-reality-experiences-unity">virtual and mixed reality experiences in Unity</a></em>.</p>
<h2 id="render-mode">Render Mode</h2>
<p>The correct Render Mode setting will make a big difference to the performance of a VR game. If you&#39;re using <a href="https://docs.unity3d.com/Packages/com.unity.xr.openxr@1.12/manual/index.html">Unity&#39;s OpenXR plugin</a> then, within the <strong>Project Settings</strong> &gt; <strong>XR Pluginmanagement</strong> &gt; <strong>plugin provider</strong>, there is a menu option for <strong>Render Mode</strong>. From the drop down select <strong>Single Pass Instanced</strong>. This mode renders both eyes in a single pass using instancing. The scene is rendered once and the shaders are run for both eyes simultaneously.</p>
<p><span id="page-97-0"></span></p>
<table>
<thead>
<tr>
<th></th>
<th>1 Inspector<br>Project Settings</th>
<th></th>
<th></th>
<th>Q</th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>* · ■ · 9<br>2 = 95</td>
<td>Adaptive Performance<br>Simulator<br>Audio</td>
<td>OpenXR</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td>0</td>
<td></td>
<td>C</td>
<td>0</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>Burst AOT Settings<br>Editor<br>Graphics<br>In-Editor Tutorials<br>Input Manager<br>V Input System Package<br>Settings<br>Memory Settings</td>
<td>Single Pass Instanced<br>Render Mode<br>Depth Submission Mode<br>None<br>Foveated Rendering Api<br>Legacy<br>Additional Graphics Queue (Vulkan)<br>System Default<br>Play Mode OpenXR Runtime</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>Package Manager<br>Physics<br>Settings<br>Physics 2D</td>
<td>Only enable interaction profiles that you actually test, to ensure their input bindings are complete.<br>Otherwise, disable that interaction profile, to allow the OpenXR runtime to remap user input from a profile<br>you do test.</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Player<br>Preset Manager</td>
<td></td>
<td>Enabled Interaction Profiles</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Quality<br>Scene Template<br>Script Execution Order<br>Services<br>ShaderGraph<br>Tags and Layers<br>TextMesh Pro<br>Time<br>Timeline<br>UI Toolkit<br>Version Control<br>VEX<br>XR Plug-in Management<br>OpenXR</td>
<td>Oculus Touch Controller Profile @<br>OpenXR Feature Groups</td>
<td></td>
<td></td>
<td>+</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>Project Validation</td>
<td>All Features</td>
<td>D-Pad Binding @</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>√ Foveated Rendering @</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>Hand Interaction Poses ®</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>Mock Runtime @</td>
<td></td>
<td>0</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>Palm Pose @</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>Runtime Debugger</td>
<td></td>
<td>0</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>XR Performance Settings @</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>Select Single Pass Instanced as the render mode when developing XR applications.</p>
<h2 id="foveated-rendering">Foveated rendering</h2>
<p>Unity 6 integrates <a href="https://docs.unity3d.com/6000.0/Documentation/Manual/xr-foveated-rendering.html">Foveated rendering</a> with support for Oculus XR and OpenXR including support for PlayStation VR2. Foveated rendering is an optimization technique for VR that leverages the human eye&#39;s tendency to focus on a small area at a time. By rendering the focal area in high resolution and the peripheral areas in lower resolution, it reduces the GPU workload significantly. Implementing foveated rendering can enhance performance, allowing for higher frame rates and improved visual quality where it matters most.</p>
<p><img src="_page_97_Picture_5.jpeg" alt=""></p>
<p>Foveated rendering, showing the focal area using high resolution</p>
<p><span id="page-98-0"></span><img src="_page_98_Picture_0.jpeg" alt=""></p>
<h2 id="utilize-the-xr-interaction-toolkit">Utilize the XR Interaction Toolkit</h2>
<p>The <a href="https://docs.unity3d.com/Packages/com.unity.xr.interaction.toolkit@3.0/manual/index.html">XR Interaction Toolkit</a> in Unity is an excellent choice for optimized input handling in XR projects. It provides a set of pre-built components and interaction systems designed to work efficiently with VR and AR hardware. By leveraging this toolkit, developers can:</p>
<p><strong>Standardize interactions:</strong> Use built-in interaction patterns to reduce custom code and ensure consistency.</p>
<p><strong>Use event-driven architecture:</strong> Utilize event-driven input handling to minimize polling and improve performance.</p>
<p><strong>Increase ease of use:</strong> Simplify the development process with ready-to-use components, leading to faster iteration and optimization.</p>
<p>Overall, the XR Interaction Toolkit helps streamline and optimize input handling, enhancing responsiveness and user experience in XR applications.</p>
<p>By implementing these strategies, you can ensure smooth and responsive input handling, enhancing the overall user experience in your XR applications.</p>
<p><img src="_page_98_Picture_9.jpeg" alt=""></p>
<p>XR Interaction Toolkit sample scene</p>
<p><span id="page-99-0"></span><img src="_page_99_Picture_0.jpeg" alt=""></p>
<h2 id="performance-testing-for-xr-optimization">Performance testing for XR optimization</h2>
<p>Performance testing is essential for ensuring your XR application delivers a smooth and immersive experience.</p>
<h4 id="-xr-specific-profilers-"><strong>XR-specific profilers:</strong></h4>
<ul>
<li><strong>Oculus Performance Head-Up Display (HUD):</strong> Real-time performance metrics</li>
<li><strong>SteamVR Performance Tool:</strong> Analyze VR application performance</li>
</ul>
<h2 id="resources-for-advanced-developers-and-artists">Resources for advanced developers and artists</h2>
<p><img src="_page_99_Picture_8.jpeg" alt=""></p>
<p>You can download many more e-books for advanced Unity developers and creators from <a href="https://unity.com/how-to">the</a>  <a href="https://unity.com/how-to">Unity best practices hub.</a> Choose from over 30 guides, created by industry experts, and Unity engineers and technical artists, that provide best practices for game development and will help you develop efficiently with Unity&#39;s toolsets and systems.</p>
<p>You&#39;ll also find tips, best practices, and news on the <a href="https://unity.com/blog">Unity Blog</a> and <a href="https://forum.unity.com/">Unity community forums,</a> as well as through <a href="https://learn.unity.com/">Unity Learn</a> and the <strong>#unitytips</strong> hashtag.</p>
<p><img src="_page_100_Picture_0.jpeg" alt=""></p>
<p><a href="https://unity.com/">unity.com</a></p>
</body></html>